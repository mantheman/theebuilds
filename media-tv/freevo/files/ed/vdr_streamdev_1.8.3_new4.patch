diff -Naur src/audio/plugins/mplayer.py src-new/audio/plugins/mplayer.py
--- src/audio/plugins/mplayer.py	2008-11-09 11:20:13.000000000 -0500
+++ src-new/audio/plugins/mplayer.py	2009-01-03 15:52:28.000000000 -0500
@@ -118,7 +118,10 @@
             filename = item.url
 
         # Build the MPlayer command
-        mpl = '--prio=%s %s -slave %s' % (config.MPLAYER_NICE, config.MPLAYER_CMD, config.MPLAYER_ARGS_DEF)
+        mpl = '--prio=%s %s -slave %s %s' % (config.MPLAYER_NICE,
+                                             config.MPLAYER_CMD,
+                                             config.MPLAYER_ARGS_DEF,
+                                             config.MPLAYER_AUDIO_ARGS)
 
         if config.DEBUG_CHILDAPP:
             mpl += ' -v'
diff -Naur src/event.py src-new/event.py
--- src/event.py	2008-11-16 13:20:46.000000000 -0500
+++ src-new/event.py	2009-01-03 15:56:52.000000000 -0500
@@ -168,6 +168,9 @@
 TV_GOTO_LIVE_PLAY      = Event('TV_GOTO_LIVE_PLAY')
 VIDEO_NEXT_FILLMODE    = Event('VIDEO_NEXT_FILLMODE')
 VIDEO_NEXT_AUDIOMODE   = Event('VIDEO_NEXT_AUDIOMODE')
+ZOOMIN                 = Event('ZOOMIN')
+ZOOMOUT                = Event('ZOOMOUT')
+ASPECT                 = Event('ASPECT')
 
 #
 # Global playing events
@@ -367,6 +370,9 @@
     '7'         : INPUT_7,
     '8'         : INPUT_8,
     '9'         : INPUT_9,
+    'ZOOMIN'    : ZOOMIN,
+    'ZOOMOUT'   : ZOOMOUT,
+    'ASPECT'    : ASPECT,
     }
 
 VIDEO_EVENTS = {
diff -Naur src/video/plugins/mplayer.py src-new/video/plugins/mplayer.py
--- src/video/plugins/mplayer.py	2008-11-30 21:42:54.000000000 -0500
+++ src-new/video/plugins/mplayer.py	2009-01-03 15:58:43.000000000 -0500
@@ -352,11 +352,25 @@
         command += str('%(playlist)s' % args).split()
         command += ['%(url)s' % args]
 
+        if config.USE_EXTRA_PARAM == 'Y' :
+            try :
+                extra_file = open( config.EXTRA_PARAM_FILE, "r")
+                param = extra_file.readline().strip()
+                extra_file.close()
+                command += param.split(' ')
+                print 'Extra Param is: %s' % (param)
+            except IOError :
+                print 'Param file does not exist'
+
         _debug_(' '.join(command[1:]))
 
         #if plugin.getbyname('MIXER'):
             #plugin.getbyname('MIXER').reset()
 
+        if len(config.MPLAYER_PRE_CMD) > 2 :
+            #print "Running MPLAYER_PRE_CMD: %s" % config.MPLAYER_PRE_CMD
+            os.system(config.MPLAYER_PRE_CMD)
+
         rc.app(self)
         self.app = MPlayerApp(command, self)
         return None
@@ -373,6 +387,10 @@
             return
 
         self.app.stop('quit\n')
+        if len(config.MPLAYER_POST_CMD) > 2 :
+            print "Running MPLAYER_POST_CMD: %s" % config.MPLAYER_POST_CMD
+            os.system(config.MPLAYER_POST_CMD)
+
         rc.app(None)
         self.app = None
 
diff -Naur src/video/plugins/xine.py src-new/video/plugins/xine.py
--- src/video/plugins/xine.py	2008-11-30 21:42:54.000000000 -0500
+++ src-new/video/plugins/xine.py	2009-01-03 15:56:52.000000000 -0500
@@ -166,6 +166,13 @@
         if not config.XINE_HAS_NO_LIRC and '--no-lirc' in command:
             command.remove('--no-lirc')
 
+        mode = item.mimetype
+
+        if not config.XINE_ARGS.has_key(mode):
+            mode = 'default'
+
+        command += config.XINE_ARGS[mode].split(' ')
+
         self.max_audio        = 0
         self.current_audio    = -1
         self.max_subtitle     = 0
--- src/tv/channels.py	2010-09-09 00:09:12.394040931 -0400
+++ src-new/tv/channels.py	2010-09-09 00:13:10.265040616 -0400
@@ -119,6 +119,65 @@
 
         return config.TV_VIDEO_GROUPS[group]
 
+    def getVideoType(self, chan):
+        """
+        Gets the VideoType used by this Freevo channel.
+        """
+        group = 0
+
+        for i in range(len(config.TV_CHANNELS)):
+            chan_info = config.TV_CHANNELS[i]
+            if chan_info[2] == chan:
+                try:
+                    group = chan_info[5]
+                except:
+                    # XXX: put a better exception here
+                    group = "broke"
+
+                break;
+
+        print "The VideoType is: %s" % group
+        return group
+
+    def getDirectStream(self, chan):
+        """
+        Gets the VideoType used by this Freevo channel.
+        """
+        direct = 0
+
+        for i in range(len(config.TV_CHANNELS)):
+            chan_info = config.TV_CHANNELS[i]
+            if chan_info[2] == chan:
+                try:
+                    direct = chan_info[6]
+                except:
+                    # XXX: put a better exception here
+                    direct = 0
+
+                break;
+
+        print "The VideoType is: %s" % direct
+        return direct
+	
+
+    def getDisplayName(self, chan):
+        """
+        Gets the VideoType used by this Freevo channel.
+        """
+        group = 0
+
+        for i in range(len(config.TV_CHANNELS)):
+            chan_info = config.TV_CHANNELS[i]
+
+            if chan_info[2] == chan:
+                try:
+                    group = chan_info[1]
+                except:
+                    # XXX: put a better exception here
+                    group = ""
+                break;
+        print "The DisplayName is: %s" % group
+        return group
 
     def chanUp(self, isplayer, app=None, app_cmd=None):
         """
--- src/tv/plugins/generic_record.py.org	2010-11-30 23:43:24.557893343 -0500
+++ src/tv/plugins/generic_record.py	2010-11-30 23:44:08.408773670 -0500
@@ -64,6 +64,7 @@
 
         _debug_('ACTIVATING GENERIC RECORD PLUGIN', DINFO)
 
+        self.current_vg = None
         self.fc = FreevoChannels()
         self.thread = Record_Thread()
         self.thread.setDaemon(1)
@@ -74,9 +75,43 @@
     def Record(self, rec_prog):
         vg = self.fc.getVideoGroup(rec_prog.tunerid, False)
 
+        __type = self.fc.getVideoType(rec_prog.tunerid)
+
         frequency = self.fc.chanSet(str(rec_prog.tunerid), False, 'record plugin')
 
-        rec_prog.filename = tv_util.getProgFilename(rec_prog)
+#        rec_prog.filename = tv_util.getProgFilename(rec_prog)
+
+        vg = self.current_vg = self.fc.getVideoGroup(rec_prog.tunerid, True)
+
+        self.rec_command = ('--prio=%s ' % config.RECORD_NICE )
+
+        print rec_prog
+
+        if vg.tuner_type == 'streamdev' :
+           rec_prog.tunerid = "%s:%s/%s" % (self.current_vg.vdev, self.current_vg.adev, rec_prog.tunerid) 
+           if __type.find('_XN') != -1 :
+               rec_prog.tunerid =  rec_prog.tunerid.replace('Extern', 'PES')
+           print "Recording http stream: %s" % (rec_prog.tunerid)
+
+        rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB
+
+        if __type.find('HD_MP') != -1 :
+           if  __type.find('MPG2p') != -1 :
+               rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '7'
+           elif  __type.find('MPG2i') != -1 :
+               rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '6'
+           elif __type.find('H264p') != -1 :  
+               rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '2'
+           elif __type.find('H264i') != -1 :  
+               rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '8'
+        elif __type.find('SD_MP') != -1 :  
+           rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '3'
+        elif __type.find('HD_XN') != -1 :
+           rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '4'
+        elif __type.find('SD_XN') != -1 :
+           rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + config.TV_RECORDFILE_SUFFIX_DVB + '5'
+
+        print "Recording filename:  %s" % (rec_prog.filename)
 
         cl_options = { 'channel'  : rec_prog.tunerid,
                        'frequency' : frequency,
@@ -91,12 +126,17 @@
                        'group-type' : vg.group_type
         }
 
-        if isinstance(config.VCR_CMD, str) or isinstance(config.VCR_CMD, unicode):
-            self.rec_command = config.VCR_CMD % cl_options
-        elif isinstance(config.VCR_CMD, list) or isinstance(config.VCR_CMD, tuple):
-            self.rec_command = []
-            for arg in config.VCR_CMD:
-                self.rec_command.append(arg % cl_options)
+        #if isinstance(config.VCR_CMD, str) or isinstance(config.VCR_CMD, unicode):
+        #    self.rec_command = config.VCR_CMD % cl_options
+        #elif isinstance(config.VCR_CMD, list) or isinstance(config.VCR_CMD, tuple):
+        #    self.rec_command = []
+        #    for arg in config.VCR_CMD:
+        #        self.rec_command.append(arg % cl_options)
+
+        if vg.tuner_type == 'streamdev' :
+            self.rec_command += config.VCR_CMD_HTTP % cl_options
+        if vg.tuner_type == 'dvb' :
+            self.rec_command += config.VCR_CMD_DVB % cl_options
 
         self.thread.mode     = 'record'
         self.thread.prog     = rec_prog
diff -Naur src/tv/plugins/dvb_atsc.py src-new/tv/plugins/dvb_atsc.py
--- src/tv/plugins/dvb_atsc.py	1969-12-31 19:00:00.000000000 -0500
+++ src-new/tv/plugins/dvb_atsc.py	2009-01-03 15:56:52.000000000 -0500
diff -Naur 1/dvb_atsc.py 2/dvb_atsc.py
@@ -0,0 +1,347 @@
+# -*- coding: iso-8859-1 -*-
+# -----------------------------------------------------------------------
+# dvb_atsc.py
+# -----------------------------------------------------------------------
+#
+# Notes:
+# Todo:        
+#
+# -----------------------------------------------------------------------
+
+# Configuration file. Determines where to look for AVI/MP3 files, etc
+import config
+
+import time, os, stat
+
+import util    # Various utilities
+import osd     # The OSD class, used to communicate with the OSD daemon
+import rc      # The RemoteControl class.
+import event as em
+import childapp # Handle child applications
+from tv.channels import FreevoChannels
+import plugin
+import subprocess
+from subprocess import Popen, PIPE
+import os.path 
+
+# Set to 1 for debug output
+DEBUG = config.DEBUG
+
+TRUE = 1
+FALSE = 0
+
+# Create the OSD object
+osd = osd.get_singleton()
+
+class PluginInterface(plugin.Plugin):
+    """
+    Plugin to watch live tv with xine (timeshifting).
+    """
+    def __init__(self):
+        plugin.Plugin.__init__(self)
+
+        # create the object and register it
+        plugin.register(dvb_atsc(), plugin.TV)
+
+
+class dvb_atsc:
+    aspect_ratio = 0
+
+    app = None
+
+    __muted    = 0
+    __igainvol = 0
+    
+    def __init__(self):
+        self.tuner_chidx = 0    # Current channel, index into config.TV_CHANNELS
+        self.app_mode = 'tv'
+        self.fc = FreevoChannels()
+        self.current_vg = None
+        self.stream_url = None
+        self.stream_cmd = None
+        self.stream_pid = 0
+        self.stream_file = config.TV_RECORD_DIR + "temp_stream.mpg" 
+        self.seek_on = 0
+        self.save_rec = 0
+        self.channel_name = ""
+        self.channel_type = ""
+        self.aspect_r = 0
+
+    def change_channel(self, channel) :
+        self.fc.chanSet(channel)
+
+        if self.app :
+           Pass
+
+    def getMPlayerCmd(self, args) :
+	return '--prio=%s %s -fs %s -slave %s' % args
+
+    def getMPlayerArgs(self) :
+        return (config.MPLAYER_NICE, config.MPLAYER_CMD, config.MPLAYER_ARGS_DEF)
+
+    def getDvbArgs(self, is_sat, type, tuner_channel, direct_stream) :
+        args = ""
+        more_opts = ""
+
+	if is_sat == 'dvb' :
+                print 'Playing a local dvb:// stream'
+
+                self.stream_url = ('dvb://%s' % tuner_channel)
+	        #self.stream_cmd = ('mplayer -dumpstream -dumpfile /tmp/test.mpg %s' % self.stream_url)
+	        self.stream_cmd = None
+                args = ('%s %s %s' % (self.stream_url, config.MPLAYER_ARGS[type], more_opts), )
+                
+        if is_sat == 'streamdev' :
+                print 'Playing a vdr-streamdev stream'
+
+                self.stream_url = ('http://%s:%s/%s' % (self.current_vg.vdev, self.current_vg.adev, tuner_channel))
+                
+                if direct_stream == 1 :
+                    self.stream_cmd = None
+                    tmp = self.stream_url
+                else :
+                    self.stream_cmd = 'wget'
+                    tmp = self.stream_file
+
+                args = ('%s %s %s' % (more_opts, config.MPLAYER_ARGS[type], tmp), )
+        return args
+
+    def Play(self, mode, tuner_channel=None):
+
+        if not tuner_channel:
+            tuner_channel = self.fc.getChannel()
+
+        vg = self.current_vg = self.fc.getVideoGroup(tuner_channel, True)
+        self.seek_on = 0
+        self.save_rec = 0
+        type = self.fc.getVideoType(tuner_channel)
+	direct_stream = self.fc.getDirectStream(tuner_channel)
+
+	print tuner_channel
+	print vg.vdev
+	print vg.adev
+	print vg.tuner_type
+       
+        self.stream_pid = 0
+        self.group_type = vg.group_type
+
+        self.channel_type = self.fc.getVideoType(tuner_channel)
+
+        if mode == 'tv':
+            if type.find('_MP') != -1 :
+                print 'Using MPlayer for Channel'
+                command = self.getMPlayerCmd( self.getMPlayerArgs() + self.getDvbArgs( vg.tuner_type, self.fc.getVideoType(tuner_channel), tuner_channel, direct_stream) )
+
+            self.channel_name = self.fc.getDisplayName(tuner_channel)
+
+            if config.USE_EXTRA_PARAM == 'Y' :
+                try :
+                    extra_file = open( config.EXTRA_PARAM_FILE, "r")
+                    param = extra_file.readline()
+                    extra_file.close()
+                    command += ' ' + param
+                    print 'Extra Param is: %s' % (param)
+                except IOError :
+                    print 'Param file does not exist'
+        else:
+            print 'Mode "%s" is not implemented' % mode  # XXX ui.message()
+            return
+
+        opts = '%s' % self.stream_file
+
+        if len(config.MPLAYER_PRE_CMD) > 2 :
+            print "Running MPLAYER_PRE_CMD: %s" % config.MPLAYER_PRE_CMD
+            os.system(config.MPLAYER_PRE_CMD)
+
+        print 'cmd: %s' % (command)
+        if self.stream_cmd != None :
+            #self.stream_pid = subprocess.Popen([self.stream_cmd, '-O', self.stream_file, self.stream_url], stdout=PIPE)
+
+            #self.stream_pid = subprocess.Popen([self.stream_cmd, '-O', "-", self.stream_url], stdout=PIPE)
+            #self.stream_pid2 = subprocess.Popen(['/usr/bin/ts_filter', self.stream_file], stdin=self.stream_pid.stdout)
+
+            self.stream_pid = subprocess.Popen([self.stream_cmd, '-O', '-', self.stream_url], stdout=PIPE)
+            self.stream_pid2 = subprocess.Popen(['/usr/bin/ffmpeg', '-y','-i', '-', '-acodec', 'copy', '-vcodec', 'copy', '-f', 'matroska', self.stream_file], stdin=self.stream_pid.stdout)
+
+            print 'stream pid: %d' % self.stream_pid.pid
+
+            count = 0
+            while not os.path.exists(self.stream_file) :
+                if count % 4 == 0 : 
+                    print 'Waiting for streaming file: %d' % (count/4)
+                count += 1
+                time.sleep(.250)
+                if count > (4*8) : 
+                    print "Waited for streaminf file, not waiting any longer"
+                    break;
+
+            if self.fc.getVideoType(tuner_channel).find('_SD_') != -1 :
+                buf_size = config.LIVE_MIN_BUF_SDTV
+            elif self.fc.getVideoType(tuner_channel).startswith('H264'):
+                buf_size = config.LIVE_MIN_BUF_H264
+            else :
+                buf_size = config.LIVE_MIN_BUF_HDTV
+
+            print "Wait Buf Size: %d" % buf_size
+            count = 0
+            tmp_size = 0
+            last_size = 0
+
+            while os.path.exists(self.stream_file) and os.stat(self.stream_file)[stat.ST_SIZE] < buf_size :
+                print "Interm Size: %d" % os.stat(self.stream_file)[stat.ST_SIZE]
+                time.sleep(.200)
+                tmp_size = os.stat(self.stream_file)[stat.ST_SIZE]  
+                if tmp_size == last_size :
+                   count += 1
+                else :
+                  last_size = tmp_size
+                if count > 75 :
+                   print "Waited for stream, not waiting any longer"
+                   break
+
+            if os.path.exists(self.stream_file) :
+                print "Final Size: %d" % os.stat(self.stream_file)[stat.ST_SIZE]
+
+            if os.path.exists(self.stream_file) and os.stat(self.stream_file)[stat.ST_SIZE] < buf_size :
+                print "Size is: %d, returning" % os.stat(self.stream_file)[stat.ST_SIZE]
+                if self.stream_pid != 0 :
+                    print "Killing PID: %d" % self.stream_pid.pid
+                    #self.stream_pid.kill()
+                    #self.stream_pid2.kill()
+                    tmp = '%d' % self.stream_pid.pid
+                    os.spawnlp(os.P_WAIT, 'kill', 'kill', tmp)
+                    try :
+                        os.remove(self.stream_file)
+                    except OSError :
+                        pass
+        self.mode = mode
+
+        # Start up the TV task
+        self.app = childapp.ChildApp2(command)
+        
+        self.prev_app = rc.app()
+        rc.app(self)
+
+        if osd.focused_app():
+            osd.focused_app().hide()
+        if DEBUG: print '%s: started %s app' % (time.time(), self.mode)
+        
+    def Stop(self, channel_change=0):
+        self.app.stop('quit\n')
+
+        rc.app(self.prev_app)
+        if osd.focused_app() and not channel_change:
+            osd.focused_app().show()
+
+        if os.path.exists('/tmp/freevo.wid'): os.unlink('/tmp/freevo.wid')
+
+
+    def eventhandler(self, event, menuw=None):
+        s_event = '%s' % event
+
+        if event == em.STOP or event == em.PLAY_END:
+            print "STOP"
+
+            if self.channel_type.find('_MP') != -1 :
+                if len(config.MPLAYER_POST_CMD) > 2 :
+                   print "Running MPLAYER_POST_CMD: %s" % config.MPLAYER_POST_CMD
+                   os.system(config.MPLAYER_POST_CMD)
+
+            if self.stream_pid != 0 :
+                print "Killing PID: %d" % self.stream_pid.pid
+                tmp = '%d' % self.stream_pid.pid
+                os.spawnlp(os.P_WAIT, 'kill', 'kill', tmp)
+                if self.save_rec == 0 :
+                    try :
+                       os.remove(self.stream_file)
+                    except OSError :
+                       pass
+                else :
+                    new_file = config.TV_RECORD_DIR + self.channel_name + "_" + time.strftime("%m_%d_%y_%H:%M:%S") + ".mpg"
+                    print "Renaming file to: %s" % new_file
+                    os.rename(self.stream_file, new_file);
+
+            self.Stop()
+            rc.post_event(em.PLAY_END)
+            return TRUE
+
+	if event == em.PLAY or event == em.PAUSE:
+            self.app.write('pause\n')
+            return True
+
+        if event == em.ASPECT:
+           if self.aspect_r == 0 :
+              print "switch_ratio:  1.33"
+              self.app.write('switch_ratio 1.3333\n')
+              self.aspect_r = 1
+              return True
+
+           if self.aspect_r == 1 :
+              print "switch_ratio:  1.44"
+              self.app.write('switch_ratio 1.4444\n')
+              self.aspect_r = 2
+              return True
+
+           if self.aspect_r == 2 :
+              print "switch_ratio:  1.55"
+              self.app.write('switch_ratio 1.5555\n')
+              self.aspect_r = 3
+              return True
+
+           if self.aspect_r == 3 :
+              print "switch_ratio:  1.66"
+              self.app.write('switch_ratio 1.6666\n')
+              self.aspect_r = 4
+              return True
+
+           if self.aspect_r == 4 :
+              print "switch_ratio:  1.77"
+              self.app.write('switch_ratio 1.7777\n')
+              self.aspect_r = 0
+           return True
+
+        if event == em.ZOOMIN:
+            return True
+
+        if event == em.ZOOMOUT:
+            return True
+
+        elif event == em.TOGGLE_OSD:
+            #self.app.write('OSDStreamInfos\n')
+            self.app.write('osd\n')
+            return TRUE
+
+        if s_event.startswith('INPUT_') :
+            if DEBUG: print "INPUT: ", int( s_event[6])
+            tmpevent = int(s_event[6]) 
+
+            if tmpevent == 1 :
+               self.app.write('audio_delay 0.100\n')
+
+            if tmpevent == 2 :
+               self.app.write('audio_delay -0.100\n')
+
+            if tmpevent == 7 :
+               self.app.write('ToggleInterleave\n')
+
+            if tmpevent == 8 :
+               self.app.write('switch_audio\n')
+
+            if tmpevent == 9 :
+               print 'Not deleting'
+               if self.save_rec == 0 :
+                   self.app.write('osd_show_text "%s"\n' % _('Saving recording'))
+                   self.save_rec = 1
+               else :
+                   self.app.write('osd_show_text "%s"\n' % _('NOT Saving recording'))
+                   self.save_rec = 0
+                
+            return TRUE     
+
+        if event == em.SEEK:
+            pos = int(event.arg)
+            action='seek '
+            self.app.write('%s%s\n' % (action, pos) )
+            return True
+        return FALSE
+    
