diff -Naur stream.org/etp/bitstream.c stream/etp/bitstream.c
--- stream.org/etp/bitstream.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/bitstream.c	2013-01-24 15:18:43.019359314 -0500
@@ -0,0 +1,201 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <math.h>
+#include <memory.h>
+
+#include "utils.h"
+#include "bitstream.h"
+
+
+#define BIT_GET_FILTER				0x80
+#define BIT_PUT_FILTER				0x01
+
+// ***********************
+// ***********************
+//
+// Bitstream functions
+//
+// ***********************
+// ***********************
+BITSTREAM * bits_create(uint8_t * stream, uint32_t len)
+{
+	BITSTREAM * b = malloc(sizeof(BITSTREAM));
+
+	b->stream = stream;
+	b->len = len;
+	b->bit_offset = 0;
+
+	return b;
+}
+
+BITSTREAM * bits_create_put(uint8_t * stream, uint32_t len)
+{
+	BITSTREAM * b = bits_create(stream, len);
+	memset(stream, 0, len);
+	return b;
+}
+
+int8_t bits_reset(BITSTREAM * b)
+{
+	int8_t r = 0;
+	if (b)
+		b->bit_offset = 0;
+	else
+		r = -1;
+	return r;
+}
+
+
+int8_t bits_peek_next_bit(BITSTREAM * b)
+{
+	int8_t r = bits_get_next_bit(b);
+
+	b->bit_offset--;
+
+	return r;
+}
+
+int8_t bits_get_next_bit(BITSTREAM * b)
+{
+	int8_t ret = -1;
+
+	if (b && b->stream && (b->bit_offset < (b->len*BYTE_SIZE)))
+	{
+		uint32_t _off = b->bit_offset - ((b->bit_offset / BYTE_SIZE) * BYTE_SIZE);
+		ret = ((b->stream[b->bit_offset++/BYTE_SIZE] & (BIT_GET_FILTER >> _off) ) >> (7 - _off));
+	}
+	return ret;
+}
+
+uint64_t bits_peek_bit_count(BITSTREAM * b, uint32_t num_of_bits, int8_t *rc)
+{
+	uint64_t r = bits_get_bit_count(b, num_of_bits, rc);
+
+	if (*rc >= 0)
+		b->bit_offset -= num_of_bits;
+	return r;
+}
+
+uint64_t bits_get_bit_count(BITSTREAM * b, uint32_t num_of_bits, int8_t *rc)
+{
+	int8_t i;
+	uint64_t ret = 0;
+
+	for (i = (num_of_bits - 1); i >= 0; i--)
+	{
+		if ((*rc = bits_get_next_bit(b)) < 0)
+			break;
+		ret |= (*rc << i);
+	}
+	return ret;
+}
+
+uint64_t bits_get_ue_golomb(BITSTREAM * b, int8_t *rc)
+{
+	uint32_t zero_count = 0;
+	uint64_t ret = 0;
+
+	while ((*rc = bits_get_next_bit(b)) == 0)
+		zero_count++;
+
+	if (zero_count && *rc >= 1)
+	{
+		uint32_t i;
+		ret = (1 << zero_count);
+
+		for (i = zero_count; i > 0; i--)
+		{
+			if ((*rc = bits_get_next_bit(b)) != -1)
+				ret |= (*rc << (i - 1));
+			else
+				break;
+		}
+		ret--;
+	}
+	return ret;
+}
+
+int64_t bits_get_se_golomb(BITSTREAM * b, int8_t *rc)
+{
+	int64_t ret = 0;
+	uint64_t tmp = 0;
+
+	tmp = bits_get_ue_golomb(b, rc);
+
+	if (*rc >= 0)
+		ret = pow(-1.0, (double)tmp + 1.0) * ceil((double)tmp / 2.0);
+
+	return ret;
+}
+
+
+uint16_t bits_get_be16(BITSTREAM * b, int8_t *rc)
+{
+	uint16_t val;
+	uint16_t tmp[2];
+
+	tmp[0] = (uint16_t) bits_get_bit_count(b, 8, rc);
+	tmp[1] = (uint16_t) bits_get_bit_count(b, 8, rc);
+	val = (tmp[0] << 8) | tmp[1];
+	return val;
+}
+
+
+uint32_t bits_get_be24(BITSTREAM * b, int8_t *rc)
+{
+	uint32_t val;
+	uint32_t tmp[2];
+
+	tmp[0] = bits_get_be16(b, rc);
+	tmp[1] = (uint16_t) bits_get_bit_count(b, 8, rc);
+	val = (tmp[0] << 16) | tmp[1];
+	return val;
+}
+
+uint32_t bits_get_be32(BITSTREAM * b, int8_t *rc)
+{
+	uint32_t val;
+	uint32_t tmp[2];
+
+	tmp[0] = (uint32_t) bits_get_be16(b, rc);
+	tmp[1] = (uint32_t) bits_get_be16(b, rc);
+	val = (tmp[0] << 16) | tmp[1];
+	return val;
+}
+
+void bits_align_8(BITSTREAM * b, int8_t *rc)
+{
+	if (b->bit_offset % 8)
+		bits_get_bit_count(b, (((b->bit_offset / 8 ) + 1) * 8) - b->bit_offset, rc);
+}
+
+
+
+uint8_t bits_invert_byte(uint8_t b)
+{
+	uint8_t c = 0;
+	c |= (0x80 & b) >> 7;
+	c |= (0x40 & b) >> 5;
+	c |= (0x20 & b) >> 3;
+	c |= (0x10 & b) >> 1;
+
+	c |= (0x8 & b) << 1;
+	c |= (0x4 & b) << 3;
+	c |= (0x2 & b) << 5;
+	c |= (0x1 & b) << 7;
+
+	return c;
+
+}
+
+
+#ifdef _MAIN_
+
+int main(int argc, char *argv[])
+{
+	return 0;
+}
+#endif
+
diff -Naur stream.org/etp/bitstream.h stream/etp/bitstream.h
--- stream.org/etp/bitstream.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/bitstream.h	2013-01-24 15:18:43.019359314 -0500
@@ -0,0 +1,29 @@
+#ifndef __BITSTREAM_STUFF
+#define __BITSTREAM_STUFF
+
+#include <stdint.h>
+
+struct bitstream_Struct
+{
+	uint32_t len;
+	uint8_t * stream;
+	uint32_t bit_offset;
+};
+typedef struct bitstream_Struct BITSTREAM;
+
+BITSTREAM * bits_create(uint8_t *, uint32_t);
+int8_t bits_reset(BITSTREAM *);
+int8_t bits_get_next_bit(BITSTREAM *);
+uint64_t bits_get_bit_count(BITSTREAM *, uint32_t, int8_t *);
+int8_t bits_peek_next_bit(BITSTREAM *);
+uint64_t bits_peek_bit_count(BITSTREAM *, uint32_t, int8_t *);
+uint64_t bits_get_ue_golomb(BITSTREAM *, int8_t *);
+int64_t bits_get_se_golomb(BITSTREAM *, int8_t *);
+void bits_align_8(BITSTREAM *, int8_t *);
+uint8_t bits_invert_byte(uint8_t);
+uint32_t bits_get_be32(BITSTREAM *, int8_t *);
+uint32_t bits_get_be24(BITSTREAM *, int8_t *);
+uint16_t bits_get_be16(BITSTREAM *, int8_t *);
+BITSTREAM * bits_create_put(uint8_t *, uint32_t);
+
+#endif
diff -Naur stream.org/etp/fastmemcpy.h stream/etp/fastmemcpy.h
--- stream.org/etp/fastmemcpy.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/fastmemcpy.h	2013-01-24 15:18:43.019359314 -0500
@@ -0,0 +1,392 @@
+/*****************************************************************************
+ * fastmemcpy.h : fast memcpy routines
+ *****************************************************************************
+ * $Id: c533aece15dd1b557cbcb31ac5fb632e41ac21f5 $
+ *
+ * Authors: various Linux kernel hackers
+ *          various MPlayer hackers
+ *          Nick Kurshev <nickols_k@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/*
+  aclib - advanced C library ;)
+  This file contains functions which improve and expand standard C-library
+*/
+
+#define BLOCK_SIZE 4096
+#define CONFUSION_FACTOR 0
+/*Feel free to fine-tune the above 2, it might be possible to get some speedup with them :)*/
+
+/*#define STATISTICS*/
+
+#ifndef HAVE_SSE2
+/*
+   P3 processor has only one SSE decoder so can execute only 1 sse insn per
+   cpu clock, but it has 3 mmx decoders (include load/store unit)
+   and executes 3 mmx insns per cpu clock.
+   P4 processor has some chances, but after reading:
+   http://www.emulators.com/pentium4.htm
+   I have doubts. Anyway SSE2 version of this code can be written better.
+*/
+#undef HAVE_SSE
+#endif
+
+
+/*
+ This part of code was taken by me from Linux-2.4.3 and slightly modified
+for MMX, MMX2, SSE instruction set. I have done it since linux uses page aligned
+blocks but mplayer uses weakly ordered data and original sources can not
+speedup them. Only using PREFETCHNTA and MOVNTQ together have effect!
+
+>From IA-32 Intel Architecture Software Developer's Manual Volume 1,
+
+Order Number 245470:
+"10.4.6. Cacheability Control, Prefetch, and Memory Ordering Instructions"
+
+Data referenced by a program can be temporal (data will be used again) or
+non-temporal (data will be referenced once and not reused in the immediate
+future). To make efficient use of the processor's caches, it is generally
+desirable to cache temporal data and not cache non-temporal data. Overloading
+the processor's caches with non-temporal data is sometimes referred to as
+"polluting the caches".
+The non-temporal data is written to memory with Write-Combining semantics.
+
+The PREFETCHh instructions permits a program to load data into the processor
+at a suggested cache level, so that it is closer to the processors load and
+store unit when it is needed. If the data is already present in a level of
+the cache hierarchy that is closer to the processor, the PREFETCHh instruction
+will not result in any data movement.
+But we should you PREFETCHNTA: Non-temporal data fetch data into location
+close to the processor, minimizing cache pollution.
+
+The MOVNTQ (store quadword using non-temporal hint) instruction stores
+packed integer data from an MMX register to memory, using a non-temporal hint.
+The MOVNTPS (store packed single-precision floating-point values using
+non-temporal hint) instruction stores packed floating-point data from an
+XMM register to memory, using a non-temporal hint.
+
+The SFENCE (Store Fence) instruction controls write ordering by creating a
+fence for memory store operations. This instruction guarantees that the results
+of every store instruction that precedes the store fence in program order is
+globally visible before any store instruction that follows the fence. The
+SFENCE instruction provides an efficient way of ensuring ordering between
+procedures that produce weakly-ordered data and procedures that consume that
+data.
+
+If you have questions please contact with me: Nick Kurshev: nickols_k@mail.ru.
+*/
+
+/* 3dnow memcpy support from kernel 2.4.2 */
+/*  by Pontscho/fresh!mindworkz           */
+
+#if defined( HAVE_MMX2 ) || defined( HAVE_3DNOW ) || defined( HAVE_MMX )
+
+#undef HAVE_MMX1
+#if defined(HAVE_MMX) && !defined(HAVE_MMX2) && !defined(HAVE_3DNOW) && !defined(HAVE_SSE)
+/*  means: mmx v.1. Note: Since we added alignment of destinition it speedups
+    of memory copying on PentMMX, Celeron-1 and P2 upto 12% versus
+    standard (non MMX-optimized) version.
+    Note: on K6-2+ it speedups memory copying upto 25% and
+          on K7 and P3 about 500% (5 times). */
+#define HAVE_MMX1
+#endif
+
+
+#undef HAVE_K6_2PLUS
+#if !defined( HAVE_MMX2) && defined( HAVE_3DNOW)
+#define HAVE_K6_2PLUS
+#endif
+
+/* for small memory blocks (<256 bytes) this version is faster */
+#define small_memcpy(to,from,n)\
+{\
+register unsigned long int dummy;\
+__asm__ __volatile__(\
+    "rep; movsb"\
+    :"=&D"(to), "=&S"(from), "=&c"(dummy)\
+/* It's most portable way to notify compiler */\
+/* that edi, esi and ecx are clobbered in asm block. */\
+/* Thanks to A'rpi for hint!!! */\
+        :"0" (to), "1" (from),"2" (n)\
+    : "memory");\
+}
+
+#ifdef HAVE_SSE
+#define MMREG_SIZE 16
+#else
+#define MMREG_SIZE 64 /*8*/
+#endif
+
+/* Small defines (for readability only) ;) */
+#ifdef HAVE_K6_2PLUS
+#define PREFETCH "prefetch"
+/* On K6 femms is faster of emms. On K7 femms is directly mapped on emms. */
+#define EMMS     "femms"
+#else
+#define PREFETCH "prefetchnta"
+#define EMMS     "emms"
+#endif
+
+#ifdef HAVE_MMX2
+#define MOVNTQ "movntq"
+#else
+#define MOVNTQ "movq"
+#endif
+
+#ifdef HAVE_MMX1
+#define MIN_LEN 0x800  /* 2K blocks */
+#else
+#define MIN_LEN 0x40  /* 64-byte blocks */
+#endif
+
+static void * fast_memcpy(void *, const void *, size_t);
+
+
+static void * fast_memcpy(void * to, const void * from, size_t len)
+{
+    void *retval;
+    size_t i;
+    retval = to;
+#ifdef STATISTICS
+    {
+        static int freq[33];
+        static int t=0;
+        int i;
+        for(i=0; len>(1<<i); i++);
+        freq[i]++;
+        t++;
+        if(1024*1024*1024 % t == 0)
+            for(i=0; i<32; i++)
+                printf("freq < %8d %4d\n", 1<<i, freq[i]);
+    }
+#endif
+#ifndef HAVE_MMX1
+        /* PREFETCH has effect even for MOVSB instruction ;) */
+    __asm__ __volatile__ (
+            PREFETCH" (%0)\n"
+            PREFETCH" 64(%0)\n"
+            PREFETCH" 128(%0)\n"
+            PREFETCH" 192(%0)\n"
+            PREFETCH" 256(%0)\n"
+        : : "r" (from) );
+#endif
+        if(len >= MIN_LEN)
+    {
+      register unsigned long int delta;
+          /* Align destinition to MMREG_SIZE -boundary */
+          delta = ((unsigned long int)to)&(MMREG_SIZE-1);
+          if(delta)
+      {
+        delta=MMREG_SIZE-delta;
+        len -= delta;
+        small_memcpy(to, from, delta);
+      }
+      i = len >> 6; /* len/64 */
+      len&=63;
+        /*
+           This algorithm is top effective when the code consequently
+           reads and writes blocks which have size of cache line.
+           Size of cache line is processor-dependent.
+           It will, however, be a minimum of 32 bytes on any processors.
+           It would be better to have a number of instructions which
+           perform reading and writing to be multiple to a number of
+           processor's decoders, but it's not always possible.
+        */
+#ifdef HAVE_SSE /* Only P3 (may be Cyrix3) */
+    if(((unsigned long)from) & 15)
+    /* if SRC is misaligned */
+    for(; i>0; i--)
+    {
+        __asm__ __volatile__ (
+        PREFETCH" 320(%0)\n"
+        "movups (%0), %%xmm0\n"
+        "movups 16(%0), %%xmm1\n"
+        "movups 32(%0), %%xmm2\n"
+        "movups 48(%0), %%xmm3\n"
+        "movntps %%xmm0, (%1)\n"
+        "movntps %%xmm1, 16(%1)\n"
+        "movntps %%xmm2, 32(%1)\n"
+        "movntps %%xmm3, 48(%1)\n"
+        :: "r" (from), "r" (to) : "memory", "xmm0", "xmm1", "xmm2", "xmm3");
+        ((const unsigned char *)from)+=64;
+        ((unsigned char *)to)+=64;
+    }
+    else
+    /*
+       Only if SRC is aligned on 16-byte boundary.
+       It allows using movaps instead of movups, which required data
+       to be aligned or a general-protection exception (#GP) is generated.
+    */
+    for(; i>0; i--)
+    {
+        __asm__ __volatile__ (
+        PREFETCH" 320(%0)\n"
+        "movaps (%0), %%xmm0\n"
+        "movaps 16(%0), %%xmm1\n"
+        "movaps 32(%0), %%xmm2\n"
+        "movaps 48(%0), %%xmm3\n"
+        "movntps %%xmm0, (%1)\n"
+        "movntps %%xmm1, 16(%1)\n"
+        "movntps %%xmm2, 32(%1)\n"
+        "movntps %%xmm3, 48(%1)\n"
+        :: "r" (from), "r" (to) : "memory", "xmm0", "xmm1", "xmm2", "xmm3");
+        ((const unsigned char *)from)+=64;
+        ((unsigned char *)to)+=64;
+    }
+#else
+    /* Align destination at BLOCK_SIZE boundary */
+    for(; ((uintptr_t)to & (BLOCK_SIZE-1)) && i>0; i--)
+    {
+        __asm__ __volatile__ (
+#ifndef HAVE_MMX1
+            PREFETCH" 320(%0)\n"
+#endif
+        "movq (%0), %%mm0\n"
+        "movq 8(%0), %%mm1\n"
+        "movq 16(%0), %%mm2\n"
+        "movq 24(%0), %%mm3\n"
+        "movq 32(%0), %%mm4\n"
+        "movq 40(%0), %%mm5\n"
+        "movq 48(%0), %%mm6\n"
+        "movq 56(%0), %%mm7\n"
+        MOVNTQ" %%mm0, (%1)\n"
+        MOVNTQ" %%mm1, 8(%1)\n"
+        MOVNTQ" %%mm2, 16(%1)\n"
+        MOVNTQ" %%mm3, 24(%1)\n"
+        MOVNTQ" %%mm4, 32(%1)\n"
+        MOVNTQ" %%mm5, 40(%1)\n"
+        MOVNTQ" %%mm6, 48(%1)\n"
+        MOVNTQ" %%mm7, 56(%1)\n"
+        :: "r" (from), "r" (to) : "memory", "mm0", "mm1", "mm2", "mm3",
+                                            "mm4", "mm5", "mm6", "mm7");
+                from = (const void *) (((const unsigned char *)from)+64);
+        to = (void *) (((unsigned char *)to)+64);
+    }
+
+/*    printf(" %p %p\n", (uintptr_t)from&1023, (uintptr_t)to&1023); */
+    /* Pure Assembly cuz gcc is a bit unpredictable ;) */
+# if 0
+    if(i>=BLOCK_SIZE/64)
+        asm volatile(
+            "xorl %%eax, %%eax    \n\t"
+            ".balign 16        \n\t"
+            "1:            \n\t"
+                "movl (%0, %%eax), %%ebx     \n\t"
+                "movl 32(%0, %%eax), %%ebx     \n\t"
+                "movl 64(%0, %%eax), %%ebx     \n\t"
+                "movl 96(%0, %%eax), %%ebx     \n\t"
+                "addl $128, %%eax        \n\t"
+                "cmpl %3, %%eax            \n\t"
+                " jb 1b                \n\t"
+
+            "xorl %%eax, %%eax    \n\t"
+
+                ".balign 16        \n\t"
+                "2:            \n\t"
+                "movq (%0, %%eax), %%mm0\n"
+                "movq 8(%0, %%eax), %%mm1\n"
+                "movq 16(%0, %%eax), %%mm2\n"
+                "movq 24(%0, %%eax), %%mm3\n"
+                "movq 32(%0, %%eax), %%mm4\n"
+                "movq 40(%0, %%eax), %%mm5\n"
+                "movq 48(%0, %%eax), %%mm6\n"
+                "movq 56(%0, %%eax), %%mm7\n"
+                MOVNTQ" %%mm0, (%1, %%eax)\n"
+                MOVNTQ" %%mm1, 8(%1, %%eax)\n"
+                MOVNTQ" %%mm2, 16(%1, %%eax)\n"
+                MOVNTQ" %%mm3, 24(%1, %%eax)\n"
+                MOVNTQ" %%mm4, 32(%1, %%eax)\n"
+                MOVNTQ" %%mm5, 40(%1, %%eax)\n"
+                MOVNTQ" %%mm6, 48(%1, %%eax)\n"
+                MOVNTQ" %%mm7, 56(%1, %%eax)\n"
+                "addl $64, %%eax        \n\t"
+                "cmpl %3, %%eax        \n\t"
+                "jb 2b                \n\t"
+
+#if CONFUSION_FACTOR > 0
+    /* a few percent speedup on out of order executing CPUs */
+            "movl %5, %%eax        \n\t"
+                "2:            \n\t"
+                "movl (%0), %%ebx    \n\t"
+                "movl (%0), %%ebx    \n\t"
+                "movl (%0), %%ebx    \n\t"
+                "movl (%0), %%ebx    \n\t"
+                "decl %%eax        \n\t"
+                " jnz 2b        \n\t"
+#endif
+
+            "xorl %%eax, %%eax    \n\t"
+            "addl %3, %0        \n\t"
+            "addl %3, %1        \n\t"
+            "subl %4, %2        \n\t"
+            "cmpl %4, %2        \n\t"
+            " jae 1b        \n\t"
+                : "+r" (from), "+r" (to), "+r" (i)
+                : "r" (BLOCK_SIZE), "i" (BLOCK_SIZE/64), "i" (CONFUSION_FACTOR)
+                : "%eax", "%ebx", "mm0", "mm1", "mm2", "mm3",
+                                  "mm4", "mm5", "mm6", "mm7"
+        );
+#endif
+
+    for(; i>0; i--)
+    {
+        __asm__ __volatile__ (
+#ifndef HAVE_MMX1
+            PREFETCH" 320(%0)\n"
+#endif
+        "movq (%0), %%mm0\n"
+        "movq 8(%0), %%mm1\n"
+        "movq 16(%0), %%mm2\n"
+        "movq 24(%0), %%mm3\n"
+        "movq 32(%0), %%mm4\n"
+        "movq 40(%0), %%mm5\n"
+        "movq 48(%0), %%mm6\n"
+        "movq 56(%0), %%mm7\n"
+        MOVNTQ" %%mm0, (%1)\n"
+        MOVNTQ" %%mm1, 8(%1)\n"
+        MOVNTQ" %%mm2, 16(%1)\n"
+        MOVNTQ" %%mm3, 24(%1)\n"
+        MOVNTQ" %%mm4, 32(%1)\n"
+        MOVNTQ" %%mm5, 40(%1)\n"
+        MOVNTQ" %%mm6, 48(%1)\n"
+        MOVNTQ" %%mm7, 56(%1)\n"
+        :: "r" (from), "r" (to) : "memory", "mm0", "mm1", "mm2", "mm3",
+                                            "mm4", "mm5", "mm6", "mm7");
+        from = (const void *) (((const unsigned char *)from)+64);
+        to = (void *) (((unsigned char *)to)+64);
+    }
+
+#endif /* Have SSE */
+#ifdef HAVE_MMX2
+                /* since movntq is weakly-ordered, a "sfence"
+         * is needed to become ordered again. */
+        __asm__ __volatile__ ("sfence":::"memory");
+#endif
+#ifndef HAVE_SSE
+        /* enables to use FPU */
+        __asm__ __volatile__ (EMMS:::"memory");
+#endif
+    }
+    /*
+     *    Now do the tail of the block
+     */
+    if(len) small_memcpy(to, from, len);
+    return retval;
+}
+
+
+#endif /* #if defined( HAVE_MMX2 ) || defined( HAVE_3DNOW ) || defined( HAVE_MMX ) */
diff -Naur stream.org/etp/mpegts.c stream/etp/mpegts.c
--- stream.org/etp/mpegts.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/mpegts.c	2013-01-24 15:18:43.019359314 -0500
@@ -0,0 +1,1202 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <math.h>
+#include <memory.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <time.h>
+
+#include "mpegts.h"
+#include "bitstream.h"
+#include "utils.h"
+#include "fastmemcpy.h"
+
+#define MPEGTS_SECTION_LEN_PLUS_CRC		9
+#define MPEGTS_SECTION_LEN_MAX			1023 // Maximum a 10 bit value can be
+
+int mpegts_verbose_mode = 0;
+
+
+//***************/
+
+int8_t _mpegts_output_write_section(MPEGTS_SECTION *, uint8_t *, uint8_t *, uint8_t);
+uint16_t _mpegts_pmt_add_program(MPEGTS_MAP_ES *, uint8_t *, uint16_t);
+int8_t mpegts_write_pat(MPEGTS_NEWPAT_STRUCT *);
+int8_t mpegts_write_pmt(MPEGTS_NEWPMT_STRUCT *);
+void mpegts_output_writepts(uint8_t *, uint64_t, uint8_t);
+
+//***************/
+
+
+MPEGTS_PACKET * mpegts_parse_packet(BITSTREAM *bitstream)
+{
+	MPEGTS_PACKET * ret = calloc(1, sizeof(MPEGTS_PACKET));
+
+	if (ret)
+	{
+		int8_t rc = 0;
+		ret->type = -1;
+		ret->sync_byte = bits_get_bit_count(bitstream, 8, &rc);
+		if (ret->sync_byte != TS_SYNC_BYTE)
+		{
+			printf("[MPEGTS] No Sync Byte, invalid MPEG-TS\n");
+			free(ret);
+			return NULL;
+		}
+
+		ret->ts_error = bits_get_next_bit(bitstream);
+		if (ret->ts_error)
+		{
+			if (mpegts_verbose_mode >= 2)
+				printf("[MPEGTS] TS_ERROR is set, bad packet\n");
+			free(ret);
+			return NULL;
+		}
+
+		ret->payload_start = bits_get_next_bit(bitstream);
+		ret->ts_priority = bits_get_next_bit(bitstream);
+		ret->pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+		ret->ts_scrambling = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+		ret->adapt_field_control = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+		ret->cont_counter = (uint8_t) bits_get_bit_count(bitstream, 4, &rc);
+
+
+		ret->packet_data = bitstream->stream;
+		ret->packet_data_size = bitstream->len;
+
+		if (mpegts_verbose_mode >= 1)
+		{
+			printf("[MPEGTS] PID: %d (%x)\n", ret->pid, ret->pid);
+			printf("[MPEGTS] payload_start: %d, cont_count: %d\n", ret->payload_start, ret->cont_counter);
+		}
+	}
+	return ret;
+}
+
+MPEGTS_PACKET * mpegts_parse_packet2(BITSTREAM *bitstream, uint16_t pmt_pid)
+{
+	MPEGTS_PACKET *packet = mpegts_parse_packet(bitstream);
+
+	if (packet)
+	{
+		if (packet->adapt_field_control ==  ADAPT_FIELD_ONLY_NO_PAYLOAD || packet->adapt_field_control ==  ADAPT_FIELD_AND_PAYLOAD )
+		{
+//			printf("parsing af...\n");
+			packet->adaptation_field = mpegts_parse_adaptation_field(bitstream);
+		}
+
+		if (packet->payload_start)
+		{
+//			printf("HMM: 0x%x 0x%x 0x%x 0x%x\n", bitstream->stream[(bitstream->bit_offset/8)], bitstream->stream[(bitstream->bit_offset/8)+1], bitstream->stream[(bitstream->bit_offset/8)+2], bitstream->stream[(bitstream->bit_offset/8)+3]);
+			if (bitstream->stream[bitstream->bit_offset/8] == 0x00)
+			{
+				if (packet->pid == 0)
+				{
+					packet->type = TID_PAT;
+					packet->pat = mpegts_parse_pat(bitstream);
+				}
+				if (pmt_pid && packet->pid == pmt_pid)
+				{
+					packet->type = TID_PMT;
+					packet->pmt = mpegts_parse_pmt(bitstream, packet->payload_start);
+				}
+				else if (bitstream->stream[(bitstream->bit_offset/8)+1] == 0x00 && bitstream->stream[(bitstream->bit_offset/8)+2] == 0x01)
+				{
+					uint32_t i = 0;
+					int8_t type = bitstream->stream[(bitstream->bit_offset/8)+3] & 0xFF;
+
+					packet->payload_start_struct = mpegts_parse_payload_start(bitstream);
+				}
+				else if (bitstream->stream[(bitstream->bit_offset/8)+1] == TID_PMT)
+				{
+					packet->type = TID_PMT;
+				}
+				else
+				{
+				}
+			}
+		}
+	}
+	else
+		printf("mpegts_parse_packet2 failed\n");
+
+	return packet;
+}
+
+
+void mpegts_print_adaptation_field(MPEGTS_ADAPTATION_FIELD *af)
+{
+	if (af)
+	{
+		printf("[MPEGTS] Printing Adaptation Field, Len: %d\n", af->adaptation_field_length);
+		printf("[MPEGTS]  ->discontinuity: %d\n", af->discontinuity);
+		printf("[MPEGTS]  ->random_access: %d\n", af->random_access);
+		printf("[MPEGTS]  ->es_prio: %d\n", af->es_prio);
+		printf("[MPEGTS]  ->pcr_flag: %d\n", af->pcr_flag);
+		if (af->pcr_flag)
+		{
+			printf("[MPEGTS]     ->pcr_base: %" PRId64 "\n", af->pcr_base);
+			printf("[MPEGTS]     ->pcr_reserved: %d\n", af->pcr_reserved);
+			printf("[MPEGTS]     ->pcr_ext: %d\n", af->pcr_ext);
+		}
+		printf("[MPEGTS]  ->opcr_flag: %d\n", af->opcr_flag);
+		printf("[MPEGTS]  ->splice_flag: %d\n", af->splice_flag);
+		printf("[MPEGTS]  ->ts_private_flag: %d\n", af->ts_private_flag);
+		printf("[MPEGTS]  ->field_ext_flag: %d\n", af->field_ext_flag);
+		printf("[MPEGTS]  ->random_access: %d\n", af->random_access);
+
+	}
+}
+
+MPEGTS_ADAPTATION_FIELD * mpegts_parse_adaptation_field(BITSTREAM *bitstream)
+{
+	MPEGTS_ADAPTATION_FIELD *tmp = NULL;
+
+	if (bitstream)
+	{
+		tmp = malloc(sizeof(MPEGTS_ADAPTATION_FIELD));
+		if (tmp)
+		{
+			int8_t rc = 0;
+
+			memset(tmp, 0, sizeof(MPEGTS_ADAPTATION_FIELD));
+
+			tmp->adaptation_field_length = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+//			printf("----- AF LEN: %d\n", tmp->adaptation_field_length);
+			if (tmp->adaptation_field_length > 0)
+			{
+				uint32_t start = bitstream->bit_offset;
+
+				tmp->discontinuity = bits_get_next_bit(bitstream);
+				tmp->random_access = bits_get_next_bit(bitstream);
+				tmp->es_prio = bits_get_next_bit(bitstream);
+				tmp->pcr_flag = bits_get_next_bit(bitstream);
+				tmp->opcr_flag = bits_get_next_bit(bitstream);
+				tmp->splice_flag = bits_get_next_bit(bitstream);
+				tmp->ts_private_flag = bits_get_next_bit(bitstream);
+				tmp->field_ext_flag = bits_get_next_bit(bitstream);
+
+				if (tmp->random_access && mpegts_verbose_mode >= 1)
+					printf("GOP\n");
+
+				if (tmp->pcr_flag)
+				{
+					tmp->pcr_base = (uint64_t) bits_get_bit_count(bitstream, 33, &rc);
+					tmp->pcr_reserved = (uint8_t) bits_get_bit_count(bitstream, 6, &rc);
+					tmp->pcr_ext = (uint16_t) bits_get_bit_count(bitstream, 9, &rc);
+				}
+
+				if (tmp->opcr_flag)
+				{
+					tmp->opcr_base = (uint64_t) bits_get_bit_count(bitstream, 33, &rc);
+					tmp->opcr_reserved = (uint8_t) bits_get_bit_count(bitstream, 6, &rc);
+					tmp->opcr_ext = (uint16_t) bits_get_bit_count(bitstream, 9, &rc);
+				}
+
+				if (tmp->splice_flag)
+					bits_get_bit_count(bitstream, 8, &rc);
+
+				if (tmp->ts_private_flag)
+				{
+					tmp->transport_private_data_length = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+					if (tmp->transport_private_data_length > 0)
+					{
+						bits_get_bit_count(bitstream, BYTE_SIZE * tmp->transport_private_data_length, &rc);
+					}
+				}
+
+				if (tmp->field_ext_flag )
+				{
+					printf("[MPEGTS] ERROR! We don't implement the adaptation field ext parsing, this is broke\n");
+				}
+				if ((bitstream->bit_offset - start) % BYTE_SIZE != 0)
+				{
+					printf("[MPEGTS] BIG PROBLEMS!\n");
+					return NULL;
+				}
+				else
+				{
+					tmp->stuffing_bytes = tmp->adaptation_field_length - ((bitstream->bit_offset - start) / 8);
+
+					if (tmp->stuffing_bytes)
+					{
+						int q;
+						uint8_t skip;
+
+						for (q = 0; q < tmp->stuffing_bytes; q++)
+						{
+							skip = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+							if (skip != MPEGTS_STUFF_BYTE)
+							{
+//								printf("[MPEGTS] Error skipping stuffing byte: %x\n", skip);
+								//return NULL;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	return tmp;
+}
+
+void mpegts_print_pat(MPEGTS_PAT *pat)
+{
+	if (pat)
+	{
+		MPEGTS_PAT_PROGRAM_STRUCT *t =  pat->first_program;
+		uint8_t program_count = 1;
+		printf("[MPEGTS] Printing PAT..\n");
+		printf("[MPEGTS]   ->table_id: %d\n", pat->table_id);
+		printf("[MPEGTS]   ->section_syntax_indicator: %d\n", pat->section_syntax_indicator);
+		printf("[MPEGTS]   ->zero: %d\n", pat->zero);
+//        printf("[MPEGTS]   ->reserved1 (should be 3): %d\n", pat->reserved1);
+		printf("[MPEGTS]   ->section_length: %d\n", pat->section_length);
+		printf("[MPEGTS]   ->transport_stream_id: %d\n", pat->transport_stream_id);
+//        printf("[MPEGTS]   ->reserved2 (should be 3): %d\n", pat->reserved2);
+		printf("[MPEGTS]   ->version_number: %d\n", pat->version_number);
+		printf("[MPEGTS]   ->current_next_indicator: %d\n", pat->current_next_indicator);
+		printf("[MPEGTS]   ->section_number: %d\n", pat->section_number);
+		printf("[MPEGTS]   ->last_section_number: %d\n", pat->last_section_number);
+		printf("[MPEGTS]   There are %d program(s) in the PAT\n", pat->program_count);
+
+		while (t)
+		{
+			printf("[MPEGTS]   (%d) ->program_number/service_id: %d\n", program_count, t->program_number);
+//            printf("[MPEGTS]   (%d) ->reserved: %d\n", program_count, t->reserved);
+			if (t->program_number)
+				printf("[MPEGTS]   (%d) ->pid: %d (0x%X) -- PMT PID\n", program_count, t->pid, t->pid);
+			else
+				printf("[MPEGTS]   (%d) ->pid: %d (0x%X) -- NIT PID\n", program_count, t->pid, t->pid);
+
+			t = t->next;
+			program_count++;
+		}
+	}
+}
+
+MPEGTS_PAT * mpegts_parse_pat(BITSTREAM *bitstream)
+{
+	MPEGTS_PAT * ret = NULL;
+	if (bitstream)
+	{
+		int8_t rc = 0;
+		uint8_t pointer = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+		if (pointer != 0)
+			printf("POINTER: %d\n", pointer);
+		if (pointer == 0)
+		{
+			int i;
+			ret = malloc(sizeof(MPEGTS_PAT));
+
+			if (ret)
+			{
+				memset((void*)ret, 0, sizeof(MPEGTS_PAT));
+
+				ret->table_id = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				ret->section_syntax_indicator = bits_get_next_bit(bitstream);
+				ret->zero = bits_get_next_bit(bitstream);
+				ret->reserved1 =  (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				ret->section_length =  (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+				ret->transport_stream_id =  (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+				ret->reserved2 = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				ret->version_number = (uint8_t) bits_get_bit_count(bitstream, 5, &rc);
+				ret->current_next_indicator = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+				ret->section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				ret->last_section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+//				printf("pat, sec_len: %d - %d\n", ret->section_length, PAT_BYTES_AFTER_SECTION_LEN);
+				for (i = 0; i < (ret->section_length - PAT_BYTES_AFTER_SECTION_LEN - CRC_LENGTH) / PAT_PROGRAM_LENGTH; i++)
+				{
+					MPEGTS_PAT_PROGRAM_STRUCT *t = malloc(sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+					memset((void*)t, 0, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+
+					t->program_number = (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+					t->reserved = (uint8_t) bits_get_bit_count(bitstream, 3, &rc);
+
+					t->pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+
+					if (!ret->first_program)
+					{
+						ret->first_program = ret->current_program = t;
+					}
+					else
+					{
+						ret->current_program->next = t;
+						ret->current_program = ret->current_program->next;
+					}
+					ret->program_count++;
+//					printf("[MPEGTS] PAT, Adding Program/Network PID: %d (0x%X) -- Count: %d\n",t->pid, t->pid, ret->program_count);
+				}
+			}
+		}
+		else
+			printf("[MPEGTS] We encountered a PAT PID, but the pointer field is non-zero.. it's bad\n");
+	}
+	return ret;
+}
+
+int8_t _mpegts_output_write_section(MPEGTS_SECTION *sec, uint8_t *data, uint8_t *ts_header, uint8_t ts_header_len)
+{
+	if (sec && sec->section_data)
+	{
+		uint16_t section_len = MPEGTS_SECTION_LEN_PLUS_CRC + sec->section_len;
+		uint8_t packet[MPEGTS_SECTION_LEN_MAX + section_len + 12];
+		uint32_t i = 0, j, crc = 0;
+
+		if (section_len > MPEGTS_SECTION_LEN_MAX)
+		{
+			printf("[MPEGTS] Section Length is too big: %d, Max: %d\n", section_len, MPEGTS_SECTION_LEN_MAX);
+			return -1;
+		}
+
+		packet[i++] = sec->table_id;
+		packet[i++] = 0xB0 | (section_len >> 8); // 0xB0 = 1 0 11 00 00 in binary
+		packet[i++] = section_len & 0xFF;        // Rest of the section length
+		packet[i++] = sec->ts_id >> 8;           // PID: PAT = 0, PMT = Variable
+		packet[i++] = sec->ts_id & 0xFF;
+
+//		tmp = sec->version_number << 1;
+//		tmp1 = 0xC1 | tmp;
+		packet[i++] = 0xC1 | (sec->version_number << 1);                      // 0xC1 = 11 00000 1 in binary
+//		printf("HMM: %x\n",  packet[i-1]);
+		packet[i++] = 0;                         // section  number
+		packet[i++] = 0;                         // last section number
+
+		for (j = 0; j < sec->section_len; j++)
+			packet[i++] = sec->section_data[j];
+
+		crc = crc32(packet, i);
+
+		packet[i++] = (crc >> 24) & 0xFF;
+		packet[i++] = (crc >> 16) & 0xFF;
+		packet[i++] = (crc >> 8) & 0xFF;
+		packet[i++] = crc & 0xFF;
+
+		if (data)
+		{
+			int j = 0;
+			memset(data, 0xFF, TS_PACKET_SIZE);
+			if (ts_header && ts_header_len)
+				fast_memcpy(data, ts_header, ts_header_len);
+			fast_memcpy(data + ts_header_len, packet, i);
+		}
+//		mpegts_output_packetize(program, packet, i, 1, 0, 0, 0);
+	}
+	return 0;
+}
+
+uint16_t _mpegts_pmt_add_program(MPEGTS_MAP_ES * program, uint8_t *packet, uint16_t i)
+{
+	int k;
+
+	packet[i++] = program->stream_type;
+
+	packet[i++] = 0xE0 | ((program->pid >> 8) & 0x1F);
+	packet[i++] = (program->pid & 0xFF);
+
+	packet[i++] = 0xF0 | (program->info_len >> 8);
+	packet[i++] = program->info_len & 0xFF;
+	for (k = 0; k < program->info_len; k++)
+	{
+		packet[i++] = program->descriptor[k];
+	}
+	return i;
+}
+
+int8_t mpegts_write_pmt(MPEGTS_NEWPMT_STRUCT *pmt)
+{
+	int8_t ret = 1;
+	if (pmt)
+	{
+		uint8_t packet[MPEGTS_SECTION_LEN_MAX + TS_PACKET_SIZE] = {0};
+		uint16_t i = 0, j = 0;
+		MPEGTS_SECTION section = {0};
+		MPEGTS_MAP_ES * tmp_es = pmt->desc_es;
+
+		section.table_id = TID_PMT;
+		section.ts_id = pmt->program_number;
+//		printf("PMT Program Num: %d\n", pmt->program_number);
+		//PCR
+		packet[i++] = 0xE0 | ((pmt->pcr_pid >> 8) & 0x1F);
+		packet[i++] = pmt->pcr_pid & 0xFF;
+
+		//PMT Descriptor, there shouldn't be one (len = 0)
+		packet[i++] = 0xF0 | (pmt->program_descriptor_len >> 8);
+		packet[i++] = pmt->program_descriptor_len & 0xFF;
+//		printf("desc len: %d\n", pmt->program_descriptor_len);
+		if (pmt->program_descriptor_len)
+		{
+			for (j = 0; j < pmt->program_descriptor_len; j++)
+				packet[i++] =pmt->program_descriptor[j];
+		}
+
+		while (tmp_es)
+		{
+//			printf("Adding, PID: %d\n", tmp_es->pid);
+			i = _mpegts_pmt_add_program(tmp_es, packet, i);
+			tmp_es = tmp_es->next;
+		}
+
+		section.section_data = packet;
+		section.section_len = i;
+
+		_mpegts_output_write_section(&section, pmt->new_pmt_data, pmt->ts_header, pmt->ts_header_len);
+
+		ret = 0;
+	}
+	return ret;
+}
+
+int8_t mpegts_write_pat(MPEGTS_NEWPAT_STRUCT *pat)
+{
+	int8_t ret = 1;
+
+	if (pat)
+	{
+		uint8_t packet[4] = {0};
+		uint16_t i = 0;
+		MPEGTS_SECTION section = {0};
+
+		section.table_id = TID_PAT;
+		section.ts_id = pat->ts_id;
+		section.version_number = pat->version;
+
+//		printf("Program Num: %d, PMT_PID: %d\n", pat->program_num, pat->pmt_pid);
+		packet[i++] = pat->program_num >> 8;
+ 		packet[i++] = pat->program_num & 0xFF;
+
+		packet[i++] = 0xE0 | ((pat->pmt_pid >> 8) & 0x1F);
+		packet[i++] = pat->pmt_pid & 0xFF;
+
+		section.section_data = packet;
+		section.section_len = i;
+
+		_mpegts_output_write_section(&section, pat->new_pat_data, pat->ts_header, pat->ts_header_len);
+
+		ret = 0;
+	}
+	return ret;
+}
+
+void mpegts_free_packet(MPEGTS_PACKET *p)
+{
+	if (p)
+	{
+		if (p->adaptation_field)
+			free(p->adaptation_field);
+
+		if (p->payload_start_struct)
+			free(p->payload_start_struct);
+
+		if (p->pat)
+			mpegts_free_pat(p->pat);
+
+		if (p->pmt)
+			mpegts_free_pmt(p->pmt);
+
+		free(p);
+	}
+}
+
+
+MPEGTS_PAT *mpegts_dup_pat(MPEGTS_PAT *pat)
+{
+	MPEGTS_PAT * ret = NULL;
+	if (pat)
+	{
+		ret = calloc(1, sizeof(MPEGTS_PAT));
+		if (ret)
+		{
+			MPEGTS_PAT_PROGRAM_STRUCT *t = pat->first_program;
+			while (t)
+			{
+				MPEGTS_PAT_PROGRAM_STRUCT * pat_pgm = calloc(1, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+				if (pat_pgm)
+				{
+					fast_memcpy(pat_pgm, t, sizeof(MPEGTS_PAT_PROGRAM_STRUCT));
+
+					if (!ret->first_program)
+					{
+						ret->first_program = ret->current_program = pat_pgm;
+					}
+					else
+					{
+						ret->current_program->next = pat_pgm;
+						ret->current_program = pat_pgm;
+					}
+				}
+
+				t = t->next;
+			}
+		}
+	}
+
+	return ret;
+}
+void mpegts_free_pat(MPEGTS_PAT *pat)
+{
+	if (pat)
+	{
+		MPEGTS_PAT_PROGRAM_STRUCT *t = pat->first_program;
+		MPEGTS_PAT_PROGRAM_STRUCT *del = NULL;
+		while (t)
+		{
+			del = t;
+			t = t->next;
+			free(del);
+		}
+		free(pat);
+	}
+}
+
+void mpegts_free_pmt(MPEGTS_PMT * pmt)
+{
+	if (pmt)
+	{
+		MPEGTS_MAP_ES * t = pmt->first_es;
+		MPEGTS_MAP_ES * del = NULL;
+
+		while (t)
+		{
+			del = t;
+			t = t->next;
+			free(del);
+		}
+
+		free(pmt);
+	}
+
+	return;
+}
+
+void mpegts_print_pmt(MPEGTS_PMT *pmt)
+{
+	if (pmt)
+	{
+		int i;
+		MPEGTS_MAP_ES * t = pmt->first_es;
+		uint8_t program_count = 1;
+
+		printf("[MPEGTS] Printing PMT..\n");
+		printf("[MPEGTS]   ->table_id: %d\n", pmt->table_id);
+		printf("[MPEGTS]   ->section_syntax_indicator: %d\n", pmt->section_syntax_indicator);
+		printf("[MPEGTS]   ->zero: %d\n", pmt->zero);
+
+		printf("[MPEGTS]   ->section_length: %d\n", pmt->section_length);
+		printf("[MPEGTS]   ->program_number: %d\n", pmt->program_number);
+		printf("[MPEGTS]   ->version_number: %d\n", pmt->version_number);
+		printf("[MPEGTS]   ->current_next_indicator: %d\n", pmt->current_next_indicator);
+		printf("[MPEGTS]   ->section_number: %d\n", pmt->section_number);
+		printf("[MPEGTS]   ->last_section_number: %d\n", pmt->last_section_number);
+		printf("[MPEGTS]   ->pcr_pid: %d\n", pmt->pcr_pid);
+		printf("[MPEGTS]   ->program_info_length: %d\n", pmt->program_info_length);
+		printf("[MPEGTS]   There are %d program(s) in the PMT\n", pmt->es_count);
+
+		while (t)
+		{
+			printf("[MPEGTS]   (%d) ->stream_type: %d (0x%X)\n", program_count, t->stream_type, t->stream_type);
+			printf("[MPEGTS]   (%d) ->pid: %d (0x%X)\n", program_count, t->pid, t->pid);
+			printf("[MPEGTS]   (%d) ->info_len: %d\n", program_count, t->info_len);
+			for(i=0; i < t->info_len; i++)
+				if (isprint(t->descriptor[i]))
+					printf("%c", t->descriptor[i]);
+				else
+					printf(".");
+			printf("\n");
+			t = t->next;
+			program_count++;
+		}
+
+	}
+}
+
+MPEGTS_PMT * mpegts_parse_pmt(BITSTREAM *bitstream, uint8_t payload_start)
+{
+	MPEGTS_PMT * pmt = NULL;
+
+	if (bitstream)
+	{
+		int8_t rc = 0;
+		uint8_t pointer = 0;
+
+		if (payload_start)
+		{
+			pointer = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+//            printf("Pointer Field: %d\n", pointer);
+			if (pointer)
+				bits_get_bit_count(bitstream, pointer * 8, &rc);
+		}
+
+//        if (packet->pointer_field == 0)
+		{
+			int32_t tmp_len = 0;
+
+			pmt = calloc(1, sizeof(MPEGTS_PMT));
+
+			if (pmt)
+			{
+				int k;
+
+				pmt->table_id = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+				if (pmt->table_id != TID_PMT)
+				{
+					if (mpegts_verbose_mode >= 1)
+						printf("[TS] PMT, TableID, 0x%x != 0x%x\n", pmt->table_id, TID_PMT);
+					free(pmt);
+					return NULL;
+				}
+				else if (mpegts_verbose_mode >= 1)
+				{
+					printf("[TS] PMT, TableID is good (0x%x)\n", pmt->table_id);
+				}
+
+				pmt->section_syntax_indicator = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);;
+				pmt->zero = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+				pmt->reserved1 = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				tmp_len = pmt->section_length = (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+				pmt->program_number = (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+				pmt->reserved2 = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+				pmt->version_number = (uint8_t) bits_get_bit_count(bitstream, 5, &rc);
+
+
+				pmt->current_next_indicator = bits_get_next_bit(bitstream);
+				pmt->section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				pmt->last_section_number = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+				pmt->reserved3 = (uint8_t) bits_get_bit_count(bitstream, 3, &rc);
+				pmt->pcr_pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+				pmt->reserved4 = (uint8_t) bits_get_bit_count(bitstream, 4, &rc);
+				pmt->program_info_length = (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+
+				if (mpegts_verbose_mode >= 1)
+					printf("[TS] PMT, PCR PID: %d\n", pmt->pcr_pid);
+
+				if (pmt->program_info_length)
+				{
+					pmt->program_info_data = malloc(pmt->program_info_length);
+					for (k = 0; k < pmt->program_info_length; k++)
+					{
+						pmt->program_info_data[k] = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+					}
+				}
+
+				tmp_len -= (pmt->program_info_length + CRC_LENGTH + PMT_BYTES_AFTER_SECTION_LEN); // Bytes left to process which are es_info's
+
+//                printf("PMT, tmp_len2: %d (%d)\n", tmp_len, PMT_CONST_LENGTH);
+				while (tmp_len > 0)
+				{
+					MPEGTS_MAP_ES * es_info = calloc(1, sizeof(MPEGTS_MAP_ES));
+//	                printf("PMT, tmp_len1: %d\n", tmp_len);
+
+					es_info->stream_type = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+					es_info->reserved1 =  (uint8_t) bits_get_bit_count(bitstream, 3, &rc);
+					es_info->pid = (uint16_t) bits_get_bit_count(bitstream, 13, &rc);
+					es_info->reserved1 = (uint8_t) bits_get_bit_count(bitstream, 4, &rc);
+					es_info->info_len = (uint16_t) bits_get_bit_count(bitstream, 12, &rc);
+
+//	                printf("PMT, stream_type: 0x%x (%d), pid: 0x%x (%d), info_len: %d\n",  es_info->stream_type, es_info->stream_type, es_info->pid, es_info->pid, es_info->info_len);
+					if (es_info->info_len)
+					{
+						int i;
+						if (es_info->info_len > tmp_len)
+						{
+							printf("BIG FREAKING ERROR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+							free(es_info);
+							break;
+						}
+						es_info->descriptor = (uint8_t*) malloc(es_info->info_len);
+						for (i = 0; i < es_info->info_len; i++)
+							es_info->descriptor[i] = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+					}
+
+					tmp_len -= (PMT_PROGRAM_LENGTH + es_info->info_len);
+//	                printf("PMT, tmp_len1: %d\n", tmp_len);
+
+					if (pmt->first_es == NULL)
+					{
+						pmt->current_es = pmt->first_es = es_info;
+					}
+					else
+					{
+						pmt->current_es->next = es_info;
+						pmt->current_es = pmt->current_es->next;
+					}
+					pmt->es_count++;
+				}
+			}
+		}
+	}
+	return pmt;
+}
+
+uint64_t mpegts_parse_pts(BITSTREAM *bitstream)
+{
+    uint64_t pts_tmp = 0;
+    uint64_t ret = 0;
+    int8_t rc = 0;
+
+    pts_tmp = (uint64_t) bits_get_bit_count(bitstream, 3, &rc);
+
+    if (bits_get_next_bit(bitstream) != 1)
+        printf("[TS] PTS or DTS ERROR! First Marker is not 1\n");
+
+    ret = (pts_tmp << 30);
+
+    pts_tmp = (uint64_t) bits_get_bit_count(bitstream, 15, &rc);
+
+    if (bits_get_next_bit(bitstream) != 1)
+        printf("[TS] PTS_ONLY ERROR! Second Marker is not 1\n");
+
+    ret |= (pts_tmp << 15);
+
+    pts_tmp = (uint64_t) bits_get_bit_count(bitstream, 15, &rc);
+
+    if (bits_get_next_bit(bitstream) != 1)
+        printf("[TS] PTS_ONLY ERROR! Third Marker is not 1\n");
+
+    ret |= (pts_tmp);
+
+    return ret;
+}
+
+MPEGTS_PAYLOAD_START * mpegts_parse_payload_start(BITSTREAM *bitstream)
+{
+    MPEGTS_PAYLOAD_START *p = NULL;
+    if (bitstream)
+    {
+        p = malloc(sizeof(MPEGTS_PAYLOAD_START));
+        if (p)
+        {
+            int8_t rc = 0;
+            uint8_t start = 0;
+            memset(p, 0, sizeof(MPEGTS_PAYLOAD_START));
+/*
+			printf("[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[bitstream->bit_offset/8],
+												bitstream->stream[(bitstream->bit_offset/8)+1],
+												bitstream->stream[(bitstream->bit_offset/8)+2],
+												bitstream->stream[(bitstream->bit_offset/8)+3]);
+*/
+            p->start_code = (uint32_t) bits_get_bit_count(bitstream, 24, &rc);
+            if (p->start_code != 0x1)
+            {
+                free(p);
+//                if (mpegts_verbose_mode >= 1)
+//				printf("[TS] Payload Start was indicated but start code does not match, broken TS\n");
+//				printf("[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[0], bitstream->stream[1], bitstream->stream[2], bitstream->stream[3]);
+//				printf("[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[4], bitstream->stream[5], bitstream->stream[6], bitstream->stream[7]);
+//				printf("[0x%x 0x%x 0x%x 0x%x]\n", bitstream->stream[8], bitstream->stream[9], bitstream->stream[10], bitstream->stream[11]);
+                return NULL;
+            }
+
+            p->stream_id = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+            p->len = (uint16_t) bits_get_bit_count(bitstream, 16, &rc);
+            p->one_zero = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+            p->pes_scrambling = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+            p->pes_priority = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->data_alignment = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->copyright = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->original = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pts_dts_flag = (uint8_t) bits_get_bit_count(bitstream, 2, &rc);
+            p->escr_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->es_rate_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->dsm_trick_mode_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->additional_copy_info_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pes_crc_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pes_extension_flag = (uint8_t) bits_get_bit_count(bitstream, 1, &rc);
+            p->pes_header_data_len = (uint8_t) bits_get_bit_count(bitstream, 8, &rc);
+
+//            printf("pes_len: %d, pes_header_len: %d\n", p->len, p->pes_header_data_len);
+
+            start  = bitstream->bit_offset / BYTE_SIZE;
+
+            switch (p->pts_dts_flag)
+            {
+                case PTS_ONLY :
+                    // '10', next 4 bits should be '0010'
+                    if (bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 1 && bits_get_next_bit(bitstream) == 0 )
+                        p->pts = mpegts_parse_pts(bitstream);
+                    else
+                        printf("[TS] PTS_ONLY - ERROR - PTS header not correct\n");
+                    break;
+
+                case PTS_AND_DTS :
+                    // '11', next 4 bits should be '0011'
+                    if (bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 1 && bits_get_next_bit(bitstream) == 1 )
+                        p->pts = mpegts_parse_pts(bitstream);
+                    else
+                        printf("[TS] PTS_AND_DTS - ERROR - PTS header not correct\n");
+
+                    //  next 4 bits should be '0001'
+                    if (bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 0 && bits_get_next_bit(bitstream) == 1 )
+                        p->dts = mpegts_parse_pts(bitstream);
+                    else
+                        printf("[TS] PTS_AND_DTS - ERROR - DTS header not correct\n");
+
+
+                    break;
+
+                case NO_PTS : // '00'
+                default:
+//                    printf("[TS] NO PTS or DTS\n");
+                    break;
+            }
+
+            if (p->escr_flag)
+            {
+                printf("PES_escr_flag\n");
+                bits_get_bit_count(bitstream, 2 + 3 + 1 + 15 + 1 + 15 + 1 + 9 + 1, &rc);
+            }
+
+            if (p->es_rate_flag)
+            {
+                printf("PES_es_rate_flag\n");
+                bits_get_bit_count(bitstream, 1 + 22 + 1, &rc);
+            }
+
+            if (p->dsm_trick_mode_flag)
+            {
+                printf("TRICK MODE -- BROKEN!!!!\n");
+            }
+
+            if (p->additional_copy_info_flag)
+            {
+                printf("PES_additional copy_info\n");
+
+                bits_get_bit_count(bitstream, 8, &rc);
+            }
+
+            if (p->pes_crc_flag)
+            {
+                printf("PES_crc\n");
+                bits_get_bit_count(bitstream, 16, &rc);
+            }
+
+            if (p->pes_extension_flag)
+            {
+                printf("PES_EXT -- BROKEN!!!!\n");
+            }
+
+            if (p->pes_header_data_len)
+            {
+                uint16_t diff = p->pes_header_data_len - (bitstream->bit_offset / BYTE_SIZE - start);
+
+                if (diff)
+                {
+                    uint8_t skip;
+                    int q;
+
+                    for (q = 0; q < diff; q++)
+                    {
+                        skip = (uint8_t) bits_get_bit_count(bitstream, BYTE_SIZE, &rc);
+                        if (skip != MPEGTS_STUFF_BYTE)
+                        {
+                            printf("[TS] Error skipping stuffing byte in PES header: %x\n", skip);
+                            return NULL;
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+    return p;
+}
+
+void mpegts_output_writepts(uint8_t *data, uint64_t ipts, uint8_t flags)
+{
+	uint32_t i = 0;
+	uint64_t p;
+	ipts = ipts & 0xfffffffffLL; // clip to 36 bits 33 bits *8 before clipping
+	data[i++] = (flags << 4) | (((ipts >> 30) & 0x07) << 1) | 1;
+	p = (((ipts >> 15) & 0x7fff) << 1) | 1;
+	data[i++] = p >> 8;
+	data[i++] = p & 0xff;
+	p = (((ipts) & 0x7fff) << 1) | 1;
+	data[i++] = p >> 8;
+	data[i++] = p & 0xff;
+}
+
+uint8_t mpegts_fix_pat(uint8_t *data, uint32_t len, uint16_t pmt_pid, uint16_t pgm_num)
+{
+	uint8_t ret = 0;
+	if (data && len && pmt_pid && pgm_num)
+	{
+		uint8_t pid = ((data[1] & 0x1F) << 8) | data[2];
+//		uint8_t ps = (data[1] & 0x40) >> 6;
+        uint8_t adapt = (data[3] & 0x30) >> 4;
+
+		if (pid == PAT_PID && data[4] == 0 && (!(adapt == ADAPT_FIELD_ONLY_NO_PAYLOAD || adapt == ADAPT_FIELD_AND_PAYLOAD)))
+		{
+			MPEGTS_NEWPAT_STRUCT *new_pat = NULL;
+			new_pat = calloc(1, sizeof(MPEGTS_NEWPAT_STRUCT));
+
+			if (new_pat)
+			{
+//				printf("Fixing PAT, cont_count: %d, pgm: %d\n", cc, tuner->org_pmt->program_number);
+				new_pat->ts_header = data;
+				new_pat->ts_header_len = 5;
+				new_pat->program_num = pgm_num;
+				new_pat->pmt_pid = pmt_pid;
+				new_pat->version = (data[10] & 0x3E) >> 1;
+				new_pat->ts_id = (data[8] << 8) | data[9];
+				mpegts_write_pat(new_pat);
+
+				if (new_pat->new_pat_data)
+				{
+//					printf("HERE1\n");
+					fast_memcpy(data, new_pat->new_pat_data, TS_PACKET_SIZE);
+				}
+
+				free(new_pat);
+			}
+		}
+		else
+		{
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
+
+uint8_t mpegts_fix_pmt(uint8_t *data, uint32_t len,  uint16_t pcr_pid, uint16_t pgm_num, MPEGTS_MAP_ES *desc_es)
+{
+	uint8_t ret = 0;
+
+	if (data && len && desc_es)
+	{
+		MPEGTS_NEWPMT_STRUCT *new_pmt = NULL;
+
+		new_pmt = calloc(1, sizeof(MPEGTS_NEWPMT_STRUCT));
+
+		if (new_pmt)
+		{
+			MPEGTS_MAP_ES *tmp_es = NULL, *del_es = NULL;
+			new_pmt->program_number = pgm_num;
+			new_pmt->pcr_pid = pcr_pid;
+//			printf("pgm: %d, pcr: %d\n", new_pmt->program_number, new_pmt->pcr_pid);
+//			printf(".. Start -- PMT\n");
+			while (desc_es)
+			{
+//				printf("..PID: %d (0x%x) -- %d (0x%x)\n", desc_es->pid, desc_es->pid, desc_es->stream_type, desc_es->stream_type);
+				switch (desc_es->stream_type)
+				{
+					case MPEGTS_STREAM_TYPE_SOMETHING:
+					case MPEGTS_STREAM_TYPE_ISO13818_V: // MPEG2 Video
+					case MPEGTS_STREAM_TYPE_ISO14496_10: // H264 Video
+					case MPEGTS_STREAM_TYPE_ISO13818_3: // MP2 Audio
+					case MPEGTS_STREAM_TYPE_USER_DATA: // AC3 Audio (usually)
+						tmp_es = desc_es;
+					break;
+
+					default:
+						tmp_es = NULL;
+					break;
+				}
+
+				if (tmp_es)
+				{
+					MPEGTS_MAP_ES * newes = calloc(1, sizeof(MPEGTS_MAP_ES));
+//					printf("BLAH: %d (0x%x)\n", tmp_es->pid, tmp_es->pid);
+
+					if (newes)
+					{
+//						printf("Adding to PMT, PID: %d, Type: 0x%x (i_len: %d)\n", tmp_es->pid, tmp_es->stream_type, tmp_es->info_len);
+						fast_memcpy(newes, tmp_es, sizeof(MPEGTS_MAP_ES));
+						newes->descriptor = NULL;
+						newes->next = NULL;
+
+						if (tmp_es->info_len)
+						{
+							newes->descriptor = calloc(1, tmp_es->info_len);
+							fast_memcpy(newes->descriptor, tmp_es->descriptor, tmp_es->info_len);
+						}
+
+//						printf("Adding... %d\n", newes->pid);
+						if (!new_pmt->desc_es)
+						{
+							new_pmt->desc_es = newes;
+//							printf("HI: %d %d\n", new_pmt->desc_es->pid, new_pmt->desc_es->stream_type);
+						}
+						else
+						{
+							tmp_es = new_pmt->desc_es;
+							while(tmp_es->next)
+								tmp_es = tmp_es->next;
+							tmp_es->next = newes;
+						}
+					}
+				}
+				desc_es = desc_es->next;
+			}
+//			printf(".. DONE -- PMT\n");
+
+			new_pmt->ts_header = data;
+			new_pmt->ts_header_len = 5;
+
+			mpegts_write_pmt(new_pmt);
+
+			if (new_pmt->new_pmt_data)
+			{
+//					printf("HERE2\n");
+				fast_memcpy(data, new_pmt->new_pmt_data, TS_PACKET_SIZE);
+			}
+
+			tmp_es = new_pmt->desc_es;
+
+			while (tmp_es)
+			{
+				del_es = tmp_es;
+//				printf("HERE: %d 0x%x -- len: %d\n", tmp_es->pid, tmp_es->stream_type, tmp_es->info_len);
+				tmp_es = tmp_es->next;
+
+				if (del_es->descriptor)
+					free(del_es->descriptor);
+
+				free(del_es);
+			}
+
+			free(new_pmt);
+		}
+	}
+	return ret;
+}
+
+MPEGTS_PTS_DTS_RESTAMP * mpegts_offset_pts_dts(uint8_t *data, uint32_t len, uint64_t offset, uint16_t pmt_pid)
+{
+	MPEGTS_PTS_DTS_RESTAMP *ret = NULL;
+
+	if (data && len && offset && pmt_pid)
+	{
+		BITSTREAM *bitstream = bits_create(data, len);
+		if (bitstream)
+		{
+			MPEGTS_PACKET * packet = mpegts_parse_packet(bitstream);
+
+			if (packet)
+			{
+				if (packet->adapt_field_control ==  ADAPT_FIELD_ONLY_NO_PAYLOAD || packet->adapt_field_control == ADAPT_FIELD_AND_PAYLOAD)
+					packet->adaptation_field = mpegts_parse_adaptation_field(bitstream);
+
+				if (packet->adapt_field_control == ADAPT_FIELD_AND_PAYLOAD || packet->adapt_field_control == ADAPT_NO_FIELD_ONLY_PAYLOAD)
+				{
+					if (!(packet->pid == PAT_PID || packet->pid == pmt_pid))
+					{
+						uint32_t write_offset = (bitstream->bit_offset/8) + 9;
+						packet->payload_start_struct = mpegts_parse_payload_start(bitstream);
+
+						if (packet->payload_start_struct)
+						{
+							MPEGTS_PAYLOAD_START *pusi = packet->payload_start_struct;
+							uint64_t new_pts = 0, new_dts = 0;
+							uint8_t tmpbits = 0, pts_dts_flags = PTS_ONLY, check_bits = PTS_ONLY;
+
+							if (pusi->pts_dts_flag == PTS_AND_DTS)
+							{
+								check_bits = 0x03;
+								pts_dts_flags = PTS_AND_DTS;
+							}
+
+							tmpbits = (data[write_offset] & 0xF0) >> 4;
+
+							if (tmpbits == check_bits)
+							{
+								uint8_t _tmp1 = 0;
+								ret = calloc(1, sizeof(MPEGTS_PTS_DTS_RESTAMP));
+								new_pts = pusi->pts;
+								new_dts = pusi->dts;
+
+								if (offset > new_pts)
+								{
+									_tmp1 = 1;
+									new_pts += MAX_33BITS;
+								}
+								new_pts -= offset;
+
+								if (new_dts)
+								{
+									if (offset > new_dts)
+										new_dts += MAX_33BITS;
+									new_dts -= offset;
+								}
+								if (new_pts > offset)
+								{
+									printf("[%d] BAD PTS!!!!!!!!!!!!, org: %" PRId64" -- new: %" PRId64" -- off: %" PRId64" (%" PRId64")\n", _tmp1, pusi->pts, new_pts, offset, offset - pusi->pts);
+								}
+
+								if (new_dts && new_dts > offset)
+									printf("BAD DTS!!!!!!!!!!!!\n");
+
+								if (ret)
+								{
+									ret->pts = new_pts;
+									ret->dts = new_dts;
+								}
+
+//								printf("Restamp (pts: %" PRId64", dts: %" PRId64") Off: %" PRId64" (pts: %" PRId64", dts: %" PRId64") \n", pusi->pts, pusi->dts, offset, new_pts, new_dts);
+
+								mpegts_output_writepts(data + write_offset, new_pts, pts_dts_flags);
+
+								if (pts_dts_flags == PTS_AND_DTS)
+									data[write_offset] |= 0x10;
+
+								write_offset += 5;
+
+								if (pts_dts_flags == PTS_AND_DTS)
+								{
+									pts_dts_flags = 0x01;
+									mpegts_output_writepts(data + write_offset, new_dts, pts_dts_flags);
+									write_offset += 5;
+								}
+							}
+						}
+					}
+				}
+				mpegts_free_packet(packet);
+			}
+			free(bitstream);
+		}
+	}
+	else
+	{
+		if (!offset)
+			printf("[MPEGTS] restamp: offset is 0\n");
+
+		if (!pmt_pid)
+			printf("[MPEGTS] restamp: but pmt_pid is 0\n");
+	}
+	return ret;
+}
+
+
+uint8_t mpegts_streamtype_valid(uint8_t id)
+{
+	if (id >= MPEGTS_VIDEO_STREAM_START && id <= MPEGTS_VIDEO_STREAM_END)
+		return MPEGTS_TYPE_VIDEO;
+
+	if ((id >= MPEGTS_AUDIO_STREAM_START && id <= MPEGTS_AUDIO_STREAM_END) || (id == MPEGTS_PRIVATE_STREAM1))
+		return MPEGTS_TYPE_AUDIO;
+
+	printf("HUH?\n");
+	return MPEGTS_TYPE_UNHANDLED;
+}
+
+
+#ifdef _MAIN_
+
+int main(int argc, char *argv[])
+{
+	return 0;
+}
+#endif
+
diff -Naur stream.org/etp/mpegts.h stream/etp/mpegts.h
--- stream.org/etp/mpegts.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/mpegts.h	2013-01-24 15:18:43.019359314 -0500
@@ -0,0 +1,386 @@
+#ifndef __MPEGTS_STUFF
+#define __MPEGTS_STUFF
+
+#include <stdint.h>
+#include "bitstream.h"
+//#include "utils2.h"
+
+#define CLOCK_90K                       90000.0
+#define CLOCK_27M                       27000000.0
+#define CLOCK_CONV                      (double)(CLOCK_27M/CLOCK_90K)
+
+#define MPEGTS_VIDEO_STREAM_START       0xE0
+#define MPEGTS_VIDEO_STREAM_END         0xEF
+#define MPEGTS_AUDIO_STREAM_START       0xC0
+#define MPEGTS_AUDIO_STREAM_END         0xDF
+#define MPEGTS_PROGRAM_END              0xB9
+#define MPEGTS_PACK_HEADER              0xBA
+#define MPEGTS_SYSTEM_HEADER            0xBB
+#define MPEGTS_PROGRAM_STREAM           0xBC
+#define MPEGTS_PRIVATE_STREAM1          0xBD
+#define MPEGTS_PADDING_STREAM           0xBE
+#define MPEGTS_PRIVATE_STREAM2          0xBF
+#define MPEGTS_ECM_STREAM               0xF0
+#define MPEGTS_EMM_STREAM               0xF1
+
+#define TS_SYNC_BYTE                    0x47
+#define TS_UNIT_START                   0x40
+#define TS_UNIT_PAYLOAD_ONLY            0x10
+#define TS_UNIT_PAYLOAD_AF              0x30
+
+#define TS_PACKET_SIZE                  188
+#define TS_HEADER_LEN                   4
+
+#define PAT_PID                         0x00
+#define CA_PID                          0x01
+#define DST_PID                         0x02
+#define IPMP_PID                        0x03
+#define PMT_PID                         0x1E0
+#define NULL_PID                        0x1FFF
+#define EIT_PID                         0x12
+
+#define TID_PAT                         0x00
+#define TID_CA                          0x01
+#define TID_PMT                         0x02
+#define TID_DES                         0x03
+#define TID_14496_SDC                   0x04
+#define TID_14496_ODC                   0x05
+#define TID_META                        0x06
+#define TID_IPMP                        0x07
+#define TID_RESERVED_START              0x08
+#define TID_RESERVED_END                0x3F
+#define TID_USER_START                  0x40
+#define TID_USER_END                    0xFE
+#define TID_FORBIDDEN                   0xFF
+
+#define ADAPT_RESERVED                  0x00
+#define ADAPT_NO_FIELD_ONLY_PAYLOAD     0x01
+#define ADAPT_FIELD_ONLY_NO_PAYLOAD     0x02
+#define ADAPT_FIELD_AND_PAYLOAD         0x03
+
+#define NO_PTS                          0x00
+#define PTS_ONLY                        0x02
+#define PTS_AND_DTS                     0x03
+
+#define AF_DISCONTINUITY                0x80
+#define AF_RANDOM_ACCESS                0x50
+#define AF_PCR                          0x10
+#define AF_ES_PRI                       0x20
+
+#define MPEGTS_STUFF_BYTE               0xFF
+
+#define CRC_LENGTH                      4  //CRC = 4 bytes
+
+#define PAT_PROGRAM_LENGTH              4  // program_number = 2 bytes
+                                           // reserved(3bit)+ [program_map_id or network_id](13bits) = 2 bytes
+
+#define PAT_BYTES_AFTER_SECTION_LEN     5  // ts_id = 2 bytes
+                                           // resevred(2bit)+version(5bit)+current_next_indicator(1bit) = 1 byte
+                                           // section number = 1 byte
+                                           // last section number = 1 byte
+
+#define PMT_BYTES_AFTER_SECTION_LEN     9  // program_number = 2 bytes
+                                           // resevred(2bit)+version(5bit)+current_next_indicator(1bit) = 1 byte
+                                           // section number = 1 byte
+                                           // last section number = 1 byte
+                                           // reserved(3bits) + PCR PID(13) = 2 bytes
+                                           // reserved(4bits) + program_info_length(12) = 2 bytes
+
+#define PMT_PROGRAM_LENGTH              5  // stream_type =  1 byte
+                                           // reserved(3bit) + elementary_pid(13bits) = 2 bytes
+                                           // reserved(4bit) + es_info_length(12bits) = 2 bytes
+
+
+#define PAT_CONST_LENGTH					(3+PAT_BYTES_AFTER_SECTION_LEN)
+#define PMT_CONST_LENGTH					(3+PMT_BYTES_AFTER_SECTION_LEN)
+
+
+
+#define MPEGTS_STREAM_TYPE_ISO13818_V		0x02  // VIDEO
+#define MPEGTS_STREAM_TYPE_ISO11172_A		0x03  // AUDIO
+#define MPEGTS_STREAM_TYPE_ISO13818_3		0x04  // AUDIO
+#define MPEGTS_STREAM_TYPE_ISO14496_10		0x1B
+#define MPEGTS_STREAM_TYPE_SOMETHING		0x80
+#define MPEGTS_STREAM_TYPE_USER_DATA		0x81
+#define MPEGTS_STREAM_TYPE_SCTE35			0x86
+
+
+#define MPEGTS_TYPE_UNHANDLED           0
+#define MPEGTS_TYPE_VIDEO               1
+#define MPEGTS_TYPE_AUDIO               2
+#define MPEGTS_TYPE_PAT                 3
+#define MPEGTS_TYPE_PMT                 4
+#define MPEGTS_TYPE_INVALID             -1
+
+
+static const uint8_t TS_NULL_PACKET[188] =
+{
+	0x47, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static const char *MPEG2_PIC_TYPE[5]=
+{
+	"Undefined",
+	"I-Frame",
+	"P-Frame",
+	"B-Frame",
+	"D-Frame",
+};
+
+struct mpegts_pat_program_struct
+{
+	uint16_t program_number;
+	uint8_t reserved;
+	uint16_t pid;
+//        uint16_t network_pid;
+//        uint16_t program_pid;
+	struct mpegts_pat_program_struct *next;
+};
+typedef struct mpegts_pat_program_struct MPEGTS_PAT_PROGRAM_STRUCT;
+
+struct mpegts_pat_struct
+{
+	uint8_t table_id;
+	uint8_t section_syntax_indicator;
+	uint8_t zero;
+	uint8_t reserved1;
+	uint16_t section_length;
+	uint16_t transport_stream_id;
+	uint8_t reserved2;
+	uint8_t version_number;
+	uint8_t current_next_indicator;
+	uint8_t section_number;
+	uint8_t last_section_number;
+	uint32_t crc;
+
+	uint16_t program_count;
+	MPEGTS_PAT_PROGRAM_STRUCT * first_program;
+	MPEGTS_PAT_PROGRAM_STRUCT * current_program;
+	uint16_t program_num_filter;
+};
+typedef struct mpegts_pat_struct MPEGTS_PAT;
+
+struct mpegts_map_es_struct
+{
+	uint8_t stream_type; //8
+	uint8_t reserved1; //3
+	uint16_t pid; //13
+	uint8_t reserved2; //4
+	uint16_t info_len; //12
+	uint8_t * descriptor;
+	struct mpegts_map_es_struct *next;
+};
+typedef struct mpegts_map_es_struct MPEGTS_MAP_ES;
+
+struct mpegts_pmt_struct
+{
+	uint8_t table_id;  // 8 bits
+	uint8_t section_syntax_indicator; //1
+	uint8_t zero; //1
+	uint8_t reserved1; //2
+	uint16_t section_length; //12
+	uint16_t program_number; //16
+	uint8_t reserved2; //2
+	uint8_t version_number; //5
+	uint8_t current_next_indicator; //1
+	uint8_t section_number; //8
+	uint8_t last_section_number; //8
+	uint8_t reserved3; //3
+	uint16_t pcr_pid; //13
+	uint8_t reserved4;  //4
+	uint16_t program_info_length; //12
+	uint8_t *program_info_data;
+
+
+	uint16_t es_count;
+	MPEGTS_MAP_ES * first_es;
+	MPEGTS_MAP_ES * current_es;
+	uint32_t crc; //32
+};
+typedef struct mpegts_pmt_struct MPEGTS_PMT;
+
+struct mpegts_payload_start_struct
+{
+//	uint8_t  start;  // Where in the packet does the payload start?
+//	uint32_t packet_num;
+
+	uint32_t start_code;
+	uint8_t stream_id;
+	uint16_t len;
+	uint8_t one_zero;
+	uint8_t pes_scrambling;
+	uint8_t pes_priority;
+	uint8_t data_alignment;
+	uint8_t copyright;
+	uint8_t original;  //1 = org, 0 = copy
+	uint8_t pts_dts_flag;
+	uint8_t escr_flag;
+	uint8_t es_rate_flag;
+	uint8_t dsm_trick_mode_flag;
+	uint8_t additional_copy_info_flag;
+	uint8_t pes_crc_flag;
+	uint8_t pes_extension_flag;
+	uint8_t pes_header_data_len;
+	uint64_t pts;
+	uint64_t dts;
+
+	uint64_t new_pts;
+	uint64_t new_dts;
+	uint8_t * extra_data;
+};
+typedef struct mpegts_payload_start_struct MPEGTS_PAYLOAD_START;
+
+struct mpegts_section
+{
+	uint8_t table_id;
+	uint8_t section_syntax_indicator;
+	uint16_t ts_id;
+	uint8_t version_number;
+	uint8_t current_next_indicator;
+	uint8_t section_number;
+	uint8_t last_section_number;
+
+	uint8_t *section_data;
+	uint16_t section_len;
+
+	void * extra_data;
+};
+typedef struct mpegts_section MPEGTS_SECTION;
+
+struct mpegts_adaptfield_struct
+{
+	uint8_t adaptation_field_length;
+	uint8_t discontinuity;
+	uint8_t random_access;
+	uint8_t es_prio;
+	uint8_t pcr_flag;
+	uint8_t opcr_flag;
+	uint8_t splice_flag;
+	uint8_t ts_private_flag;
+	uint8_t field_ext_flag;
+	uint64_t pcr_baseH;
+	uint64_t pcr_base;
+	uint8_t pcr_reserved;
+	uint16_t pcr_ext;
+
+	uint8_t stuffing_bytes;
+	uint64_t pcr_27khz;
+
+	uint64_t opcr_base;
+	uint8_t opcr_reserved;
+	uint16_t opcr_ext;
+
+	uint8_t transport_private_data_length;
+	uint8_t * transport_private_data;
+
+	/* add other adapatation field flags */
+};
+typedef struct mpegts_adaptfield_struct MPEGTS_ADAPTATION_FIELD;
+
+struct mpegts_struct
+{
+	uint8_t sync_byte;
+	uint8_t ts_error;               // 1
+	uint8_t payload_start;  // 1
+	uint8_t ts_priority;    // 1
+	uint16_t pid;           // 13
+	uint8_t ts_scrambling;  // 2
+	uint8_t adapt_field_control;    // 2
+	uint8_t cont_counter;   // 4
+	uint8_t pointer_field;
+	uint8_t transport_private_data_length;
+	uint8_t splice_countdown;
+	void * extra_data;
+
+	MPEGTS_ADAPTATION_FIELD * adaptation_field;
+	MPEGTS_PAYLOAD_START * payload_start_struct;
+
+	BITSTREAM *bitstream;
+
+	uint8_t * packet_data;
+	uint8_t packet_data_size;
+
+	int8_t type;
+	uint8_t frame_type;
+	uint8_t pmt_descriptor;
+	MPEGTS_PAT *pat;
+	MPEGTS_PMT *pmt;
+};
+typedef struct mpegts_struct MPEGTS_PACKET;
+
+
+
+struct mpegts_newpat_struct
+{
+	uint16_t program_num;
+	uint16_t pmt_pid;
+	uint16_t ts_id;
+	uint8_t version;
+	uint8_t counter;
+	uint8_t new_pat_data[TS_PACKET_SIZE];
+	uint8_t *ts_header;
+	uint8_t ts_header_len;
+};
+typedef struct mpegts_newpat_struct MPEGTS_NEWPAT_STRUCT;
+
+struct mpegts_newpmt_struct
+{
+	uint16_t program_number;
+	uint16_t pcr_pid;
+	uint8_t *program_descriptor;
+	uint16_t program_descriptor_len;
+	uint8_t counter;
+	uint8_t new_pmt_data[TS_PACKET_SIZE];
+	uint8_t *ts_header;
+	uint8_t ts_header_len;
+	MPEGTS_MAP_ES * desc_es;
+
+};
+typedef struct mpegts_newpmt_struct MPEGTS_NEWPMT_STRUCT;
+
+struct mpegts_pts_dts_restamp
+{
+	uint64_t org_pts;
+	uint64_t org_dts;
+	uint64_t pts;
+	uint64_t dts;
+};
+typedef struct mpegts_pts_dts_restamp MPEGTS_PTS_DTS_RESTAMP;
+
+// -----------------------------------------------------------
+
+void mpegts_print_adaptation_field(MPEGTS_ADAPTATION_FIELD *);
+void mpegts_print_pat(MPEGTS_PAT *);
+void mpegts_print_pmt(MPEGTS_PMT *);
+
+MPEGTS_PACKET * mpegts_parse_packet(BITSTREAM *);
+MPEGTS_PACKET * mpegts_parse_packet2(BITSTREAM *, uint16_t);
+MPEGTS_PAYLOAD_START * mpegts_parse_payload_start(BITSTREAM *);
+MPEGTS_ADAPTATION_FIELD * mpegts_parse_adaptation_field(BITSTREAM *);
+MPEGTS_PAT * mpegts_parse_pat(BITSTREAM *);
+MPEGTS_PAT *mpegts_dup_pat(MPEGTS_PAT *);
+MPEGTS_PMT * mpegts_parse_pmt(BITSTREAM *, uint8_t);
+
+void mpegts_free_pat(MPEGTS_PAT *);
+void mpegts_free_pmt(MPEGTS_PMT *);
+void mpegts_free_packet(MPEGTS_PACKET *);
+
+uint64_t mpegts_parse_pts(BITSTREAM *);
+uint8_t mpegts_fix_pat(uint8_t *, uint32_t, uint16_t, uint16_t);
+uint8_t mpegts_fix_pmt(uint8_t *data, uint32_t len,  uint16_t, uint16_t, MPEGTS_MAP_ES *);
+MPEGTS_PTS_DTS_RESTAMP * mpegts_offset_pts_dts(uint8_t *, uint32_t, uint64_t, uint16_t);
+
+uint8_t mpegts_streamtype_valid(uint8_t);
+
+#endif
diff -Naur stream.org/etp/protocol.c stream/etp/protocol.c
--- stream.org/etp/protocol.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/protocol.c	2013-01-24 15:18:43.019359314 -0500
@@ -0,0 +1,469 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <memory.h>
+#include <getopt.h>
+#include <pthread.h>
+#include <errno.h>
+#include <signal.h>
+#include <ctype.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include "protocol.h"
+#include "utils.h"
+
+
+size_t _protocol_send_cmd(int, PROTOCOL_CMD_STRUCT *);
+
+size_t _protocol_send_8(int, uint8_t);
+size_t _protocol_send_16(int, uint16_t);
+size_t _protocol_send_32(int, uint32_t);
+size_t _protocol_send_64(int, uint64_t);
+
+size_t _protocol_get_8(int, uint8_t*);
+size_t _protocol_get_16(int, uint16_t*);
+size_t _protocol_get_32(int, uint32_t*);
+size_t _protocol_get_64(int, uint64_t*);
+
+// --------------------------
+
+// ---------- SENDs
+size_t _protocol_send_64(int handle, uint64_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint64_t));
+	return -1;
+}
+size_t _protocol_send_32(int handle, uint32_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint16_t));
+	return -1;
+}
+
+size_t _protocol_send_16(int handle, uint16_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint16_t));
+	return -1;
+}
+
+size_t _protocol_send_8(int handle, uint8_t p)
+{
+	if (handle)
+		return write(handle, &p, sizeof(uint8_t));
+	return -1;
+}
+
+//  ------------ GETSs
+size_t _protocol_get_64(int handle, uint64_t *p)
+{
+	if (handle)
+		return read(handle, &p, sizeof(uint64_t));
+	return -1;
+}
+size_t _protocol_get_32(int handle, uint32_t *p)
+{
+	if (handle)
+		return read(handle, &p, sizeof(uint16_t));
+	return -1;
+}
+
+size_t _protocol_get_16(int handle, uint16_t *p)
+{
+	if (handle)
+		return read(handle, &p, sizeof(uint16_t));
+	return -1;
+}
+
+size_t _protocol_get_8(int handle, uint8_t *p)
+{
+	if (handle)
+		return read(handle, &p, sizeof(uint8_t));
+	return -1;
+}
+
+
+// -----------------------------=
+size_t protocol_send_tuner_pos(int handle, uint64_t pos)
+{
+	if (handle && pos)
+		return _protocol_send_64(handle, pos);
+	return -1;
+}
+
+size_t protocol_send_tuner_init_status(int handle, uint8_t stat)
+{
+	if (handle && stat)
+		return _protocol_send_8(handle, stat);
+	return -1;
+}
+
+size_t protocol_send_tuner_id(int handle, uint8_t id)
+{
+	if (handle && id)
+		return _protocol_send_8(handle, id);
+	return -1;
+}
+
+size_t protocol_get_tuner_time_pos(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_get_tuner_id(int handle)
+{
+	if (handle)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_ID;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+uint64_t protocol_get_tuner_time_endpos(int handle)
+{
+	uint64_t ret = 0;
+	if (handle)
+	{
+		size_t tmp;
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_GET_STREAM_END_POS;
+		pstruct.dataptr_size = 0;
+		pstruct.dataptr = NULL;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+//-----------------------------------------
+
+size_t protocol_set_tuner_channel(int handle, uint32_t channel)
+{
+	if (handle && channel)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_TUNE_AND_STREAM;
+		pstruct.dataptr_size = sizeof(channel);
+		pstruct.dataptr = (uint8_t*)&channel;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_set_tuner_time_pos(int handle, uint64_t pos)
+{
+	if (handle && pos)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_SET_STREAM_POS;
+		pstruct.dataptr_size = sizeof(pos);
+		pstruct.dataptr = (uint8_t*)&pos;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+size_t protocol_set_tuner_writing(int handle, uint8_t pos)
+{
+	if (handle && pos)
+	{
+		PROTOCOL_CMD_STRUCT pstruct = {0};
+
+		pstruct.cmd = PROTO_SET_WRITING;
+		pstruct.dataptr_size = sizeof(pos);
+		pstruct.dataptr = (uint8_t*)&pos;
+
+		return _protocol_send_cmd(handle, &pstruct);
+	}
+	return -1;
+}
+
+void protocol_free_cmd_struct(PROTOCOL_CMD_STRUCT * p)
+{
+	if (p)
+	{
+		if (p->dataptr)
+			free(p->dataptr);
+		free(p);
+	}
+}
+
+PROTOCOL_CMD_STRUCT *protocol_get_cmd(int handle)
+{
+	PROTOCOL_CMD_STRUCT *ret = NULL;
+
+	if (handle)
+	{
+		uint32_t _input = 0;
+		size_t _rc = 0;
+
+		_rc = read(handle, &_input, sizeof(uint32_t));
+		if (_rc <= 0)
+			return NULL;
+
+		if (!((_input & PROTO_CMD_MASK) == PROTO_CMD_START))
+			return NULL;
+
+		ret = calloc(1, sizeof(PROTOCOL_CMD_STRUCT));
+		if (!ret)
+			return NULL;
+
+		ret->cmd = _input & 0x000000FF;
+
+		switch(ret->cmd)
+		{
+			case PROTO_SET_WRITING:
+			case PROTO_SET_STREAM_POS:
+			case PROTO_TUNE_AND_STREAM:
+			{
+				//uint32_t data_sz = 0;
+				_rc = read(handle, &ret->dataptr_size, sizeof(ret->dataptr_size));
+
+				if (_rc == sizeof(ret->dataptr_size))
+				{
+					//ret->dataptr_size = data_sz;
+					ret->dataptr = malloc(ret->dataptr_size);
+					_rc = read(handle, ret->dataptr, ret->dataptr_size);
+				}
+				else
+				{
+					printf("MOO\n");
+				}
+			}
+			break;
+
+			case PROTO_INIT_CONNECTION:
+			case PROTO_GET_STREAM_END_POS:
+			case PROTO_GET_STREAM_POS:
+			case PROTO_GET_STREAM_ID:
+			default:
+
+			break;
+		}
+	}
+	return ret;
+}
+
+size_t _protocol_send_cmd(int handle, PROTOCOL_CMD_STRUCT *protocol)
+{
+	size_t _rc = -1;
+	if (handle && protocol)
+	{
+		uint32_t _send = (PROTO_CMD_START | protocol->cmd);
+//		printf("send: %d\n", (int32_t)_send);
+
+
+		_rc = write(handle, &_send, sizeof(_send));
+		if (_rc <= 0)
+			return -1;
+
+//		printf("send1: %d\n", protocol->dataptr_size);
+		if (protocol->dataptr_size)
+		{
+			_rc = write(handle, &protocol->dataptr_size, sizeof(protocol->dataptr_size));
+			if (_rc <= 0)
+				return -1;
+
+
+			_rc = write(handle, protocol->dataptr, protocol->dataptr_size);
+			if (_rc <= 0)
+				return -1;
+		}
+
+		_rc = 1;
+
+	}
+	return _rc;
+}
+
+//******************************************************
+#ifdef _MAIN_
+
+
+uint8_t ugly[188*3] = {0};
+
+void display_usage(char *exe)
+{
+	fprintf(stderr,"bleah\n");
+}
+
+
+static const char *optString = "a:l:p:m:c:d:?h";
+
+static const struct option longOpts[] =
+{
+	{ "listenip", required_argument, NULL, 'l' },
+	{ "listenport", required_argument, NULL, 'p' },
+	{ "tuners", required_argument, NULL, 'm' },
+	{ "hdhrip", required_argument, NULL, 'c' },
+	{ "hdhrport", required_argument, NULL, 'd' },
+
+	{ "help", no_argument, NULL, 'h' },
+	{ NULL, no_argument, NULL, 0 }
+};
+
+uint8_t get_opts(int argc, char *const argv[])
+{
+	int index = 0;
+	int opt = getopt_long( argc, argv, optString, longOpts, &index );
+
+	if (opt == -1 )
+	{
+		display_usage(argv[0]);
+		return 1;
+	}
+
+
+	while ( opt != -1 )
+	{
+		switch ( opt )
+		{
+			case 'l':
+//				__bindip = optarg;
+				break;
+
+			case 'p':
+//				__bindport = atoi(optarg);
+				break;
+
+			case 'm':
+//				__maxtuners = atoi(optarg);
+				break;
+
+			case 'c':
+//				__hdhr_channels_file = optarg;
+				break;
+
+			case 'a':
+//				__hdhr_dev_name = optarg;
+				break;
+
+			case 'd':
+//				__devport = atoi(optarg);
+				break;
+
+			case 'h':
+			case '?':
+				display_usage(argv[0]);
+				break;
+
+			default:
+				break;
+		}
+		opt = getopt_long( argc, argv, optString, longOpts, &index );
+	}
+	return 0;
+}
+
+void sigint_handler()
+{
+	exit(0);
+}
+
+void sigpipe_handler()
+{
+//   printf("SIGPIPE caught\n");
+}
+
+void doconnect(char *ip, uint16_t port, uint32_t channel)
+{
+	if (ip && port)
+	{
+		struct sockaddr_in dest;
+		int sock = 0, sz, i, j;
+		char req[1024] = {0}, in=0, last=0;
+		uint8_t moo=0xFF;
+
+		sock = socket(AF_INET, SOCK_STREAM, 0);
+		memset(&dest, 0, sizeof(dest));
+		dest.sin_family = AF_INET;
+		dest.sin_addr.s_addr = inet_addr(ip);
+		dest.sin_port = htons(port);
+
+		sz = connect(sock, (struct sockaddr *)&dest, sizeof(struct sockaddr));
+		if (sz == -1)
+		{
+			printf("[CeTUNE] Problem connecting: %s\n", strerror(errno));
+			return;
+		}
+
+		sprintf(req, "eTUNER V001 \n\n");
+		sz = write_bytes_to_handle(sock, (uint8_t*)req, strlen(req), 2, 0);
+
+		if (sz ==  -1)
+		{
+			printf("[CeTUNE] Error sending GET req\n");
+			close(sock);
+			return;
+//			continue;
+		}
+
+		memset(&req, 0, 1024);
+		sz = get_bytes_from_handle(sock, &moo, 1, 5, 0, 0);
+
+		if (sz == -1)
+		{
+			close(sock);
+//			continue;
+		}
+
+		if (moo == PROTOCOL_INIT_GOOD)
+		{
+//			printf("2: 0x%x, chan: %d\n", moo, channel);
+			protocol_send_tuner_channel(sock, channel);
+		}
+
+		while (1)
+		{
+			sz = get_bytes_from_handle(sock, &ugly[0], 188*3, 5, 0, 0);
+//			printf("sz: %d\n", sz);
+			printf(".");
+			if (sz == -1)
+			{
+				break;
+			}
+			usleep(250);
+		}
+		close(sock);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	signal(SIGPIPE,sigpipe_handler);
+	signal(SIGINT,sigint_handler);
+
+	doconnect(argv[1], atoi(argv[2]), atoi(argv[3]));
+//	usleep(1000 *1000 * 10);
+//	get_opts(argc, argv);
+	printf("BYE!\n");
+	return 0;
+}
+#endif
+
diff -Naur stream.org/etp/protocol.h stream/etp/protocol.h
--- stream.org/etp/protocol.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/protocol.h	2013-01-24 15:18:43.020359314 -0500
@@ -0,0 +1,52 @@
+#ifndef __TUNER_PROTOCOL_STUFF
+#define __TUNER_PROTOCOL_STUFF
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+//#include "utils.h"
+
+#define PROTOCOL_INIT_STR				"eTUNER INIT"
+
+#define PROTOCOL_INIT_BAD				0xD0
+#define PROTOCOL_INIT_GOOD				0xD1
+
+#define PROTO_CMD_START					0xEDEDED00
+#define PROTO_CMD_FILTER				0x000000FF
+#define PROTO_CMD_MASK					0xFFFFFF00
+
+#define PROTO_INIT_CONNECTION			1
+#define PROTO_TUNE_AND_STREAM			2
+#define PROTO_SET_STREAM_POS			3
+#define PROTO_GET_STREAM_END_POS		4
+#define PROTO_GET_STREAM_POS			5
+#define PROTO_GET_STREAM_ID				6
+#define PROTO_SET_WRITING				7
+
+struct protocol_cmd_struct
+{
+	uint8_t cmd;
+	uint8_t *dataptr;
+	uint32_t dataptr_size;
+};
+typedef struct protocol_cmd_struct PROTOCOL_CMD_STRUCT;
+
+// Defines
+PROTOCOL_CMD_STRUCT *protocol_get_cmd(int);
+
+size_t protocol_set_tuner_channel(int, uint32_t);
+size_t protocol_set_tuner_time_pos(int, uint64_t);
+
+size_t protocol_get_tuner_time_pos(int);
+size_t protocol_get_tuner_time_endpos(int);
+size_t protocol_get_tuner_id(int);
+
+size_t protocol_send_tuner_init_status(int, uint8_t);
+size_t protocol_send_tuner_pos(int, uint64_t);
+size_t protocol_send_tuner_id(int, uint8_t);
+void protocol_free_cmd_struct(PROTOCOL_CMD_STRUCT *);
+size_t protocol_set_tuner_writing(int, uint8_t);
+
+// End of Function Declarations
+
+#endif
diff -Naur stream.org/etp/utils.c stream/etp/utils.c
--- stream.org/etp/utils.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/utils.c	2013-01-24 15:18:43.020359314 -0500
@@ -0,0 +1,464 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <memory.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <time.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <sys/time.h>
+
+
+#include "utils.h"
+#include "fastmemcpy.h"
+
+#define RW_TIMEOUT 100
+
+static const uint32_t __crc_table[256] =
+{
+	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
+	0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
+	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
+	0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
+	0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
+	0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
+	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
+	0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
+	0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
+	0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
+	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
+	0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
+	0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
+	0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
+	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
+	0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
+	0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+
+uint32_t crc32(uint8_t *data, uint32_t len)
+{
+	uint32_t i;
+	uint32_t crc = 0xFFFFFFFF;
+
+	for (i = 0; i < len; i++)
+		crc = (crc << 8) ^ __crc_table[((crc >> 24) ^ *data++) & 0xFF];
+	return crc;
+}
+
+
+
+// ------------------------------
+TEXTFILE_IN_MEMORY * memfile_init(char *data, int len)
+{
+	TEXTFILE_IN_MEMORY * ret = NULL;
+	if (data && len)
+	{
+		ret = calloc(1, sizeof(TEXTFILE_IN_MEMORY));
+		ret->data = (uint8_t *)data;
+		ret->data_size = len;
+		if (1)
+		{
+			int i;
+			for(i=0; i < len; i++)
+			{
+				if(ret->data[i] == '\n')
+					ret->line_count++;
+			}
+		}
+	}
+	return ret;
+}
+
+int memfile_getline_count(TEXTFILE_IN_MEMORY *m)
+{
+	if (m)
+		return m->line_count;
+	return -1;
+}
+
+char * memfile_getnext_line(TEXTFILE_IN_MEMORY *m, int mem)
+{
+	char *ret = NULL;
+	if (m && m->pos < m->data_size)
+	{
+		int i;
+
+		for(i=m->pos; i < m->data_size; i++)
+		{
+			if (m->data[i] == '\n' || m->data[i] == '\0')
+			{
+				m->data[i] = '\0';
+				break;
+			}
+		}
+
+		if (i > m->pos)
+		{
+			ret = (char *) &m->data[m->pos];
+			m->pos = (i+1);
+		}
+	}
+	return ret;
+}
+
+int get_bytes_from_handle(int handle, uint8_t * data, int len, long int s, long int us, uint32_t block)
+{
+    int bytes_in = -1;
+	int tmp_count = 0;
+
+	if (handle >= 0 && data && len > 0)
+	{
+		struct stat buffer = {0};
+		int bytes_read = 0, rc = 0, extra = 0;
+		int want = len, status, flags;
+		fd_set readfds = {0};
+		struct timeval tv = {0};
+
+		if (block)
+			status = fstat(handle, &buffer);
+
+//		printf("r1: %ld %ld\n", s, us);
+
+		do
+		{
+			FD_ZERO(&readfds);
+			FD_SET(handle, &readfds);
+			tv.tv_sec = s;
+			tv.tv_usec = us; // ms, not micro
+/*
+			tv.tv_sec = 1;
+			tv.tv_usec = 0;
+*/
+			rc = select(handle + 1, &readfds, NULL, NULL, &tv);
+
+//			printf("MOO: %d -- %d\n", rc, tmp_count);
+			tmp_count++;
+			if (tmp_count > 3)
+			{
+//				printf("[UTILS] Timeout on select(): %s (%d) (h: %d)\n", strerror(errno), errno, handle);
+				rc = -1;
+			}
+//			if (rc == 0)
+//				printf("W1\n");
+		}
+		while (rc == 0);
+
+		if (rc == -1)
+		{
+//			printf("[UTILS] TimeOut on select(): %s (%d) (h: %d)\n", strerror(errno), errno, handle);
+            return -2;
+		}
+
+        bytes_in = 0;
+		tmp_count = 0;
+		bytes_read = 0;
+
+		if (block && S_ISCHR(buffer.st_mode))
+		{
+			flags = fcntl(handle, F_GETFL, 0);
+			fcntl(handle, F_SETFL, flags | O_NONBLOCK);
+		}
+
+        while (bytes_in < len)
+        {
+//			printf("1: %d -- %d [c: %d f: %d s: %d, r: %d]\n", want, ioctl(handle, FIONREAD, &status), S_ISCHR(buffer.st_mode),  S_ISFIFO(buffer.st_mode), S_ISSOCK(buffer.st_mode), S_ISREG(buffer.st_mode));
+//			printf("read1()\n");
+
+            bytes_read = read(handle, &data[bytes_in], want);
+//			printf("read2(): r: %d want: %d\n", bytes_read, want);
+			tmp_count++;
+
+            if (bytes_read == -1 || tmp_count > RW_TIMEOUT)
+			{
+				if (block && S_ISCHR(buffer.st_mode))
+				{
+//					printf("r4, errno: %d (%s) %d\n", errno, strerror(errno), tmp_count);
+
+					usleep(block);
+					if ((tmp_count/1000)/1000 > 4)
+					{
+						printf("[UTILS] Non-block exit\n");
+						return -1;
+					}
+					continue;
+				}
+
+				if (bytes_in <= 0)
+					return -1;
+				else
+					return bytes_in;
+			}
+			else if (bytes_read == 0)
+			{
+				usleep(1000);
+			}
+
+            bytes_in += bytes_read;
+            want -= bytes_read;
+//			printf("2: %d\n", bytes_read);
+        }
+
+		if (block && S_ISCHR(buffer.st_mode))
+			fcntl(handle, F_SETFL, flags);
+    }
+    return bytes_in;
+}
+
+int write_bytes_to_handle(int handle, uint8_t * data, int len, long int s, long int us)
+{
+    int bytes_out = -1;
+	int tmp_count = 0;
+
+    if (handle >= 0 && data && len > 0)
+    {
+        int bytes_write = 0, rc = 0;
+        int want = len;
+        fd_set writefds;
+        struct timeval tv;
+
+        do
+        {
+            FD_ZERO(&writefds);
+            FD_SET(handle, &writefds);
+/*
+            tv.tv_sec = s;
+            tv.tv_usec = us; // ms, not micro
+*/
+
+            tv.tv_sec = 1;
+            tv.tv_usec = 0; // ms, not micro
+            rc = select(handle + 1, NULL, &writefds, NULL, &tv);
+/*
+			tmp_count++;
+			if (tmp_count > 3)
+				rc = -1;
+*/
+        }
+        while (rc == 0);
+
+        if (rc == -1)
+            return rc;
+
+        bytes_out = 0;
+		tmp_count = 0;
+
+        while (bytes_out < len)
+        {
+            bytes_write = write(handle, &data[bytes_out], want);
+
+            if (bytes_write == -1 || tmp_count > RW_TIMEOUT)
+			{
+				if (bytes_out <= 0)
+					return -1;
+				else
+					return bytes_out;
+			}
+			else if (bytes_write == 0)
+			{
+				usleep(1000);
+			}
+			tmp_count++;
+
+            bytes_out += bytes_write;
+            want -= bytes_write;
+        }
+    }
+    return bytes_out;
+}
+
+off_t get_file_size(char *filename)
+{
+    if (filename)
+    {
+        struct stat st1 = {0};
+        stat(filename, &st1);
+        return st1.st_size;
+    }
+    return 0;
+}
+
+int8_t file_exists(char *filename)
+{
+	int fh = open(filename, O_RDONLY);
+	if (fh <= 0)
+		return -1;
+	close(fh);
+	return 0;
+}
+
+
+unsigned int htoi (const char *ptr)
+{
+	unsigned int value = 0;
+	char ch = *ptr;
+
+	while (ch == ' ' || ch == '\t')
+		ch = *(++ptr);
+
+	for (;;)
+	{
+		if (ch >= '0' && ch <= '9')
+			value = (value << 4) + (ch - '0');
+		else if (ch >= 'A' && ch <= 'F')
+			value = (value << 4) + (ch - 'A' + 10);
+		else if (ch >= 'a' && ch <= 'f')
+			value = (value << 4) + (ch - 'a' + 10);
+		else
+			return value;
+		ch = *(++ptr);
+	}
+}
+
+
+char *get_local_time(void)
+{
+	char *ret = calloc(1, 128);
+	char buffer[512] = {0};
+	time_t curtime = {0};
+	struct tm *loctime = NULL;
+	curtime = time (NULL);
+	loctime = localtime (&curtime);
+	strftime(ret, 128, "%I:%M%P", loctime);
+	return ret;
+}
+
+char *get_local_date(void)
+{
+	char *ret = calloc(1, 128);
+	char buffer[512] = {0};
+	time_t curtime = {0};
+	struct tm *loctime = NULL;
+	curtime = time (NULL);
+	loctime = localtime (&curtime);
+	strftime(ret, 128, "%x", loctime);
+	return ret;
+}
+
+int get_listen_socket(char * ip, uint16_t port)
+{
+	int server_socket = -1;
+	socklen_t address_len;
+	struct sockaddr_storage address;
+	struct addrinfo *addrinfo, hints;
+	char portnumber[10];
+	int yes = 1;
+
+	sprintf(portnumber, "%d", port);
+
+	memset((void *)&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_ADDRCONFIG | AI_PASSIVE;
+
+	if ((getaddrinfo(ip, portnumber, &hints, &addrinfo) != 0) || (addrinfo == NULL))
+	{
+		printf("[TUNER] getaddrinfo() failed..\n");
+		return -1;
+	}
+
+	if (addrinfo->ai_addrlen > sizeof(struct sockaddr_storage))
+	{
+		printf("[TUNER] Weird, failing..\n");
+		freeaddrinfo(addrinfo);
+		return -1;
+	}
+
+	address_len = addrinfo->ai_addrlen;
+	fast_memcpy(&address, addrinfo->ai_addr, addrinfo->ai_addrlen);
+	freeaddrinfo(addrinfo);
+
+	server_socket = socket(address.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	if (server_socket < 0)
+	{
+		printf("[TUNER] socket() failed\n");
+		return -1;
+	}
+
+	if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
+	{
+		printf("[TUNER] setsockopt failed\n");
+		return -1;
+	}
+
+	if (bind(server_socket, (struct sockaddr *) &address, address_len) < 0)
+	{
+		printf("[TUNER] Couldn't bind: %s\n", strerror(errno));
+		close(server_socket);
+		return -1;
+	}
+	listen(server_socket, 1);
+//	printf("[TUNER] Listen on IP/Port: %s/%s\n", ip, portnumber);
+	return server_socket;
+}
+
+
+size_t generic_curl_handler(void *buffer, size_t size, size_t nmemb, void *userp)
+{
+	UTILS_DATAPAIR_STRUCT *carg = NULL;
+
+	if (buffer && size > 0 && nmemb > 0 && userp)
+	{
+		size_t last_sz = 0;
+
+		carg = (UTILS_DATAPAIR_STRUCT *)userp;
+		last_sz = carg->data_size;
+
+		if (carg->data)
+		{
+			carg->data = realloc(carg->data, carg->data_size + nmemb);
+			carg->data_size += nmemb;
+		}
+		else
+		{
+			carg->data = malloc(nmemb);
+			carg->data_size = nmemb;
+		}
+		fast_memcpy(carg->data + last_sz, buffer, nmemb);
+	}
+	return nmemb;
+}
+
+uint32_t get_time_ms(void)
+{
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (uint32_t)((tv.tv_sec) * 1000 + (tv.tv_usec) / 1000);
+}
+
+
+#ifdef _MAIN_
+
+int main(int argc, char *argv[])
+{
+	return 0;
+}
+#endif
diff -Naur stream.org/etp/utils.h stream/etp/utils.h
--- stream.org/etp/utils.h	1969-12-31 19:00:00.000000000 -0500
+++ stream/etp/utils.h	2013-01-24 15:18:43.020359314 -0500
@@ -0,0 +1,79 @@
+#ifndef __UTILS_STUFF
+#define __UTILS_STUFF
+
+#include <stdint.h>
+#include <inttypes.h>
+
+#define BYTE_SIZE				8
+
+#define MAX_33BITS				0x1FFFFFFFF
+
+#define SLEEP_250MS				usleep(250000);
+#define SLEEP_100MS				usleep(100000);
+#define SLEEP_50MS				usleep(50000);
+#define SLEEP_1MS				usleep(1000);
+
+#define MAX_FILENAME_SIZE		(4096*2)
+#define FILE_INPUT_READ_MIN		1000000
+#define FILE_INPUT_STDIN		"stdin"
+#define FILE_INPUT_STDIN_FD		0
+
+#define FILE_OUTPUT_STDOUT		"stdout"
+#define FILE_OUTPUT_STDOUT_FD		1
+
+#ifndef MIN
+#define MIN(a,b) ( (a)<(b) ? (a) : (b) )
+#endif
+
+#ifndef MAX
+#define MAX(a,b) ( (a)>(b) ? (a) : (b) )
+#endif
+
+struct utils_datapair_struct
+{
+	uint8_t * data;
+	uint32_t data_size;
+	void * extra;
+};
+typedef struct utils_datapair_struct UTILS_DATAPAIR_STRUCT;
+
+
+// --------------------------
+struct textfile_in_memory
+{
+    int pos;
+    int line_count;
+    int data_size;
+    uint8_t *data;
+};
+typedef struct textfile_in_memory TEXTFILE_IN_MEMORY;
+
+struct textfile_memline
+{
+	int line_num;
+	char *line_data;
+};
+typedef struct textfile_memline TEXTFILE_MEMLINE;
+
+// Function declarations
+// **************************************
+TEXTFILE_IN_MEMORY * memfile_init(char *, int);
+char * memfile_getnext_line(TEXTFILE_IN_MEMORY *, int);
+int memfile_getline_count(TEXTFILE_IN_MEMORY *);
+
+
+int8_t file_exists(char *);
+off_t get_file_size(char *);
+int write_bytes_to_handle(int, uint8_t *, int, long int, long int);
+int get_bytes_from_handle(int, uint8_t *, int, long int, long int, uint32_t);
+
+int get_listen_socket(char *, uint16_t);
+size_t generic_curl_handler(void *, size_t, size_t, void *);
+unsigned int htoi (const char *);
+
+char *get_local_time(void);
+char *get_local_date(void);
+uint32_t crc32(uint8_t *, uint32_t);
+uint32_t get_time_ms(void);
+
+#endif
