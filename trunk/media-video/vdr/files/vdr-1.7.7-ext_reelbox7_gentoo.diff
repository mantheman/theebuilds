diff -ruNp vdr-1.7.7-extensions/config.h vdr-1.7.7-ext-reelbox7/config.h
--- vdr-1.7.7-extensions/config.h	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/config.h	2009-05-04 21:22:59.000000000 +0200
@@ -272,12 +272,17 @@ private:
   void StoreSourceCaps(const char *Name);
   bool ParseSourceCaps(const char *Value);
 #endif /* SOURCECAPS */
+#ifndef USE_EHD
   cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+#endif /* EHD */
   void Store(const char *Name, const char *Value, const char *Plugin = NULL, bool AllowMultiple = false);
   void Store(const char *Name, int Value, const char *Plugin = NULL);
   void Store(const char *Name, double &Value, const char *Plugin = NULL);
 public:
   // Also adjust cMenuSetup (menu.c) when adding parameters here!
+#ifdef USE_EHD
+  cSetupLine *Get(const char *Name, const char *Plugin = NULL);
+#endif /* EHD */
   int __BeginData__;
   char OSDLanguage[I18N_MAX_LOCALE_LEN];
   char OSDSkin[MaxSkinName];
@@ -385,6 +390,12 @@ public:
   bool SourceCapsSet;
 #endif /* SOURCECAPS */
   int CurrentChannel;
+#ifdef USE_EHD
+  // Reel OSDPip
+  int CurrentPipChannel;
+  int PipIsActive;
+  int PipIsRunning;
+#endif /* EHD */
   int CurrentVolume;
   int CurrentDolby;
   int InitialChannel;
diff -ruNp vdr-1.7.7-extensions/dvdIndex.c vdr-1.7.7-ext-reelbox7/dvdIndex.c
--- vdr-1.7.7-extensions/dvdIndex.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/dvdIndex.c	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,198 @@
+#ifdef USE_EHD
+#include <string.h> 			//strdup()
+#include <stdio.h>  			//popen ()
+#include "dvdIndex.h"
+
+/// computes sha1 sum of a directory by
+// listing all files of the directory and their respective sizes
+
+/**
+ *  cd _mount_point_
+ *  ls -Rl | awk '{ if ( NF >= 8 ) printf "%s %s ", $5,  $8}' ==> get the size ($5) and the name ($8) of all files in _mount_point_
+ *  sha1sum ==> compute SHA1 sum
+ *  ... awk to get the first column which is the sha1sum
+ */
+
+std::string SHA_directory(std::string dir)
+{
+	char cmd [512];
+	char* sha1_str=NULL;
+
+	sprintf( cmd, "cd \"%s\" ; ls -Rl |\
+			awk '{ if ( NF >= 8 ) printf \"%%s %%s \", $5,  $8}' |\
+			sha1sum | awk '{print $1}' ", 
+			dir.c_str() );
+
+	FILE *p = popen(cmd, "r"); // code from devicesetup.c -  device::mount()
+	if (p) {
+		char s[64];
+		fscanf(p," %s", s);
+		sha1_str = strdup(s);
+	}
+	pclose(p);
+
+	return sha1_str; // len(sha1_str) != 40 => ERROR
+
+}
+
+
+/// ---- class cDataBaseEntry -------------
+// one entry of DataBase
+cDataBaseEntry::cDataBaseEntry()		 { }
+cDataBaseEntry::cDataBaseEntry( string plName, string volName, long long mSize, long long t )
+{ 
+	pluginName = plName; 
+	volumeName = volName;
+	lastMounted = t?t:time(0);  // present time
+	mediaSize = mSize;
+}
+
+time_t 		cDataBaseEntry::LastMounted() 	{ return lastMounted; }
+long long 	cDataBaseEntry::MediaSize() 	{ return mediaSize; }
+string 		cDataBaseEntry::VolName() 		{ return volumeName; }
+string 		cDataBaseEntry::PluginName() 	{ return pluginName; }
+
+
+///---- class CMediaDataBase ----------
+
+cMediaDataBase::cMediaDataBase(string fileName) 
+{ 
+	dbFile = fileName; 
+	mediaDB.clear(); 
+	Read();
+	dbIter=mediaDB.begin();
+}       ///
+
+bool cMediaDataBase::Next(cDataBaseEntry& node) // get current entry, and increament dbIter
+{
+	if ( mediaDB.size() <= 0 || dbIter == mediaDB.end() ) return false;
+
+	node = dbIter->second;
+	dbIter++;
+	return true;
+}
+
+void cMediaDataBase::Rewind() // goto the first entry in DB
+{
+	dbIter = mediaDB.begin();
+}
+
+
+bool cMediaDataBase::Save()            /// writes mediaDB object to the DataBase in HDD
+{
+	FILE *fp = fopen(dbFile.c_str(),"w+");
+	if (!fp) return false;
+
+	int flag= -1; // so if for-loop is skipped => nothing written to HDD => nothing saved .ie return false
+	map<string, cDataBaseEntry>::iterator it = mediaDB.begin();
+
+	for ( ; it != mediaDB.end() ; it++)
+	{
+		flag = fprintf(fp, "%s\t%s\t%s\t%lld\t%lld\n", 
+				it->first.c_str(), it->second.PluginName().c_str() , 
+				it->second.VolName().c_str(), it->second.MediaSize(),
+				(long long)it->second.LastMounted() );
+
+		if (flag<0) // error
+		{ 
+			printf("(%s:%d) flag < 0: not saved\n",__FILE__,__LINE__);
+			break;
+		}
+	}
+
+	fclose(fp);
+	return (flag >= 0);
+
+}
+
+
+bool cMediaDataBase::Read()            /// reads from HDD, and populates mediaDB object 
+{
+
+	if ( access( dbFile.c_str(), F_OK ) != 0 ) // file does not exist
+	{
+		printf("(%s:%d) db doesnot exist!! \n", __FILE__, __LINE__);
+		mediaDB.clear();
+		return true;
+	}
+	FILE *fp = fopen(dbFile.c_str(), "r");
+	if ( !fp ) // read error!
+	{
+		printf("(%s:%d) read error: %s \n", __FILE__, __LINE__, dbFile.c_str());
+		return false; // mediaDB not modified
+	}
+
+	// tmp DB
+	map<string, cDataBaseEntry> tmpDB;
+	string plName, volName, key;
+	long long t, s;
+	char buffer[512];
+	int flag = -1;
+
+	while( !feof(fp) )
+	{
+		flag = fscanf(fp, " %s",buffer); // key
+		key = buffer;
+		if (flag<0) break;
+
+		flag = fscanf(fp, " %s",buffer); // pluginName
+		plName = buffer;
+		if (flag<0) break;
+
+		flag = fscanf(fp, " %s",buffer); // VolName
+		volName = buffer;
+		if (flag<0) break;
+
+		flag = fscanf(fp, " %lld", &s); // size
+		if (flag<0) break;
+		flag = fscanf(fp, " %lld", &t); // time
+		if (flag<0) break;
+		/// TODO replace with a single fscanf()
+
+
+		cDataBaseEntry node (plName, volName, s, t);
+		tmpDB[key] = node;
+
+	} // end while
+
+	if ( flag<0 && ferror(fp) ) // flag alone might indicate EOF
+	{ fclose(fp); printf("flag=%d\n",flag); return false; }
+
+	fclose(fp);
+	mediaDB.clear();
+	mediaDB.insert( tmpDB.begin(), tmpDB.end() );
+	return true;
+} //end Read()
+
+bool cMediaDataBase::Add(string hashKey, cDataBaseEntry node)
+{
+	mediaDB[hashKey] = node ;
+	return Save();
+}
+
+/// add new entry into DataBase: calls Save() after updating mediaDB object
+bool cMediaDataBase::Add(string hashKey, string plName, string volName, long long s) 
+{
+	cDataBaseEntry node(plName, volName, s);
+	return Add(hashKey, node);
+}
+
+void cMediaDataBase::Remove(string hashKey) /// remove entry and write it to HDD
+{ 
+	mediaDB.erase(hashKey); 
+	Save(); 
+}  
+
+long cMediaDataBase::Size()  /// number of entries
+{ 
+	return mediaDB.size(); 
+}           
+
+void cMediaDataBase::Clear()  /// clears DataBase
+{ 
+	mediaDB.clear(); 
+	Save(); 
+}        
+
+/// end class  cMediaDataBase
+#endif /* EHD */
diff -ruNp vdr-1.7.7-extensions/dvdIndex.h vdr-1.7.7-ext-reelbox7/dvdIndex.h
--- vdr-1.7.7-extensions/dvdIndex.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/dvdIndex.h	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,65 @@
+#ifdef USE_EHD
+#ifndef __DVDINDEX_H__
+#define __DVDINDEX_H__
+
+
+#include <map>
+#include <string>
+#include <time.h>
+
+#define DVD_DB_FILENAME "/etc/vdr/DVD.db"
+// TODO: replace with ConfigDirectory/DVD.db
+
+using namespace std;
+
+std::string SHA_directory(std::string);
+
+/// one entry in the Database
+class cDataBaseEntry
+{
+	private:
+		string pluginName;       // which of the plugins of mediad accessed the medium
+		string volumeName;       //  
+		time_t lastMounted;      // last-time when the media was inserted. automatically set in constructor
+		long long mediaSize;
+	public:
+		cDataBaseEntry(); 
+		cDataBaseEntry( string plName, string volName, long long mSize, long long t=0 );
+		time_t LastMounted(); 
+		long long MediaSize();
+		string VolName();
+		string PluginName();
+};
+
+
+/// The DataBase: needs a unique "key" : now using SHA1
+class cMediaDataBase
+{
+	private:
+	/// DB in data structure
+	map<string, cDataBaseEntry> mediaDB;  
+	map<string, cDataBaseEntry>::iterator dbIter;  /// DB iterator
+	/// the database file
+	string dbFile; 
+	public:
+	cMediaDataBase(string fileName);
+
+	// get current entry, and increament dbIter
+	bool Next(cDataBaseEntry& node); 
+	void Rewind(); // goto the first entry in DB
+
+	bool Save();            /// writes mediaDB object to the DataBase in HDD
+	bool Read();            /// reads from HDD, and populates mediaDB object 
+
+	/// add new entry into DataBase: calls Save() after updating mediaDB object
+	bool Add(string hashKey, cDataBaseEntry node);
+	bool Add(string hashKey, string plName, string volName, long long s); // XXX: remove this function
+	void Remove(string hashKey); /// remove entry and write it to HDD
+
+	long Size();  /// number of entries
+	void Clear();  /// clears DataBase and writes to DB
+};
+
+
+#endif
+#endif /* EHD */
diff -ruNp vdr-1.7.7-extensions/font.h vdr-1.7.7-ext-reelbox7/font.h
--- vdr-1.7.7-extensions/font.h	2009-05-03 13:00:19.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/font.h	2009-05-04 21:22:59.000000000 +0200
@@ -37,6 +37,14 @@ class cFont {
 private:
   static cFont *fonts[];
 public:
+#ifdef USE_EHD
+  enum { NUMCHARS = 256 };
+  typedef uint32_t tPixelData;
+  struct tCharData {
+         tPixelData width, height;
+         tPixelData lines[1];
+         };
+#endif /* EHD */
   virtual ~cFont() {}
   virtual int Width(uint c) const = 0;
           ///< Returns the width of the given character in pixel.
diff -ruNp vdr-1.7.7-extensions/Make.common vdr-1.7.7-ext-reelbox7/Make.common
--- vdr-1.7.7-extensions/Make.common	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/Make.common	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,141 @@
+
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+APIVERSION = $(shell grep 'define APIVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+
+VDRLOCALE = $(shell grep '^LOCALEDIR' $(VDRDIR)/Makefile)
+
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include -I$(DVBDIR)/include
+DEFINES  += -D_GNU_SOURCE -D_LARGEFILE_SOURCE
+
+ifdef DEBUG
+  DEFINES += -DDEBUG
+  CXXFLAGS += -g
+endif
+
+ifdef RBLITE
+  DEFINES += -DRBLITE
+endif
+
+ifdef RBMINI
+  DEFINES += -DRBMINI
+endif
+
+ifdef REELVDR
+  DEFINES += -DREELVDR
+endif
+
+### Targets:
+
+plug: libvdr-$(PLUGIN).so
+
+all: libvdr-$(PLUGIN).so i18n
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DPLUGIN_NAME='"$(PLUGIN)"' -DPLUGIN_NAME_I18N='"$(PLUGIN)"' $(INCLUDES) -o $@ $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c)   > $@
+
+-include $(DEPFILE)
+
+
+### Internationalization (I18N):
+ifneq ($(strip $(VDRLOCALE)),)
+### do gettext based i18n stuff
+
+PODIR     = po
+LOCALEDIR = $(VDRDIR)/locale
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, \
+		$(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/$(PLUGIN).pot
+
+%.mo: %.po
+	msgfmt -c -o $@ $<
+
+$(I18Npot): $(wildcard *.c $(PLUGIN).h)
+	echo $(I18Nmsgs)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --from-code=utf-8 --msgid-bugs-address='<reelbox-devel@mailings.reelbox.org>' $^ -o $@
+
+#%.po:
+%.po: $(I18Npot)
+	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
+	@touch $@
+
+$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.mo
+	@mkdir -p $(dir $@)
+	cp $< $@
+
+.PHONY: i18n
+i18n: $(I18Npot) $(I18Nmsgs)
+
+#i18n-dist: $(I18Nmsgs)
+i18n-dist:
+	for i in `ls po/*.po` ; do \
+		odir=`echo $$i | cut -b4-8` ;\
+		msgfmt -c -o $(LOCALEDIR)/$$odir/LC_MESSAGES/vdr-$(PLUGIN).mo $$i ;\
+	done
+
+else ### do i18n.c based i18n stuff
+
+i18n:
+	@### nothing to do
+
+#i18n compatibility generator:
+i18n.c: i18n-template.c po2i18n.pl $(I18Npo)
+	./po2i18n.pl < i18n-template.c > i18n.c
+
+endif
+
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LDFLAGS) $(LIBS) -o $@
+	@cp $@ $(LIBDIR)/$@.$(APIVERSION)
+
+dist: distclean
+	@rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.filelist
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.pcs
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevses
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Examples/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Patch/CVS
+	@ln -s $(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE) $(PLUGIN)
+	@rm -rf $(TMPDIR)/$(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(PODIR)/*.mo
+	@-rm -f $(OBJS) $(MAIN) $(DEPFILE) *.so *.tgz core* *~
+	@-rm -f $(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION)
+
+distclean: clean
+	@-rm -f $(PODIR)/*.pot
+
+MAKECOMMON_IS_SOURCED = 1
diff -ruNp vdr-1.7.7-extensions/Make.config.template vdr-1.7.7-ext-reelbox7/Make.config.template
--- vdr-1.7.7-extensions/Make.config.template	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/Make.config.template	2009-05-04 21:22:59.000000000 +0200
@@ -82,6 +82,7 @@ LIEMIEXT = 1
 PLUGINAPI = 1
 PLUGINMISSING = 1
 #PLUGINPARAM = 1
+EHD = 1
 #ROTOR = 1
 SETTIME = 1
 #SETUP = 1
@@ -233,6 +234,16 @@ ifdef PLUGINPARAM
 DEFINES += -DUSE_PLUGINPARAM
 endif
 
+ifdef EHD
+DEFINES += -DUSE_EHD
+endif
+
+
+
+
+
+
+
 ifdef ROTOR
 DEFINES += -DUSE_ROTOR
 endif
diff -ruNp vdr-1.7.7-extensions/Makefile vdr-1.7.7-ext-reelbox7/Makefile
--- vdr-1.7.7-extensions/Makefile	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/Makefile	2009-05-04 21:22:59.000000000 +0200
@@ -43,6 +43,10 @@ OBJS = audio.o channels.o ci.o config.o 
        skinclassic.o skins.o skinsttng.o sources.o spu.o status.o svdrp.o themes.o thread.o\
        timers.o tools.o transfer.o vdr.o videodir.o
 
+ifdef EHD
+OBJS += dvdIndex.o resumeDvd.o reelboxbase.o
+endif
+
 ifdef WAREAGLEICON
 OBJS += iconpatch.o
 endif
diff -ruNp vdr-1.7.7-extensions/osdbase.h vdr-1.7.7-ext-reelbox7/osdbase.h
--- vdr-1.7.7-extensions/osdbase.h	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/osdbase.h	2009-05-04 21:22:59.000000000 +0200
@@ -98,9 +98,13 @@ public:
 
 class cOsdMenu : public cOsdObject, public cList<cOsdItem> {
 private:
+#ifndef USE_EHD
   static cSkinDisplayMenu *displayMenu;
+#endif /* EHD */
   static int displayMenuCount;
+#ifndef USE_EHD
   static int displayMenuItems;
+#endif /* EHD */
   char *title;
   int cols[cSkinDisplayMenu::MaxTabs];
   int first, current, marked;
@@ -115,6 +119,9 @@ private:
 #endif /* LIEMIEXT */
 protected:
   void SetDisplayMenu(void);
+#ifdef USE_EHD
+  static int displayMenuItems;
+#endif /* EHD */
   cSkinDisplayMenu *DisplayMenu(void) { return displayMenu; }
   const char *hk(const char *s);
   void SetCols(int c0, int c1 = 0, int c2 = 0, int c3 = 0, int c4 = 0);
@@ -141,6 +148,9 @@ protected:
 public:
   cOsdMenu(const char *Title, int c0 = 0, int c1 = 0, int c2 = 0, int c3 = 0, int c4 = 0);
   virtual ~cOsdMenu();
+#ifdef USE_EHD
+  static cSkinDisplayMenu *displayMenu;
+#endif /* EHD */
   virtual bool NeedsFastResponse(void) { return subMenu ? subMenu->NeedsFastResponse() : cOsdObject::NeedsFastResponse(); }
   int Current(void) const { return current; }
   void Add(cOsdItem *Item, bool Current = false, cOsdItem *After = NULL);
diff -ruNp vdr-1.7.7-extensions/osd.c vdr-1.7.7-ext-reelbox7/osd.c
--- vdr-1.7.7-extensions/osd.c	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/osd.c	2009-05-04 21:22:59.000000000 +0200
@@ -384,13 +384,20 @@ bool cBitmap::SetXpm(const char *const X
               if (strncmp(Xpm[i + 1], s, c) == 0) {
                  if (i == NoneColorIndex)
                     NoneColorIndex = MAXNUMCOLORS;
+#ifdef USE_EHD
+                 SetIndexFast(x, y, (IgnoreNone && i > NoneColorIndex) ? i - 1 : i);
+#else
                  SetIndex(x, y, (IgnoreNone && i > NoneColorIndex) ? i - 1 : i);
+#endif /* EHD */
                  break;
                  }
               }
           s += c;
           }
       }
+#ifdef USE_EHD
+  UpdateDirty(0,0,w-1,h-1);
+#endif /* EHD */
   if (NoneColorIndex < MAXNUMCOLORS && !IgnoreNone)
      return SetXpm(Xpm, true);
   return true;
@@ -428,6 +435,67 @@ void cBitmap::DrawBitmap(int x, int y, c
      y -= y0;
      if (ReplacePalette && Covers(x + x0, y + y0, x + x0 + Bitmap.Width() - 1, y + y0 + Bitmap.Height() - 1)) {
         Replace(Bitmap);
+#ifdef USE_EHD
+        for (int iy = 0; iy < Bitmap.height; iy++) {
+            const int lineStart = Bitmap.width * iy;
+            for (int ix = 0; ix < Bitmap.width; ix++) {
+                if (!Overlay || Bitmap.bitmap[lineStart + ix] != 0)
+                   SetIndexFast(x + ix, y + iy, Bitmap.bitmap[lineStart + ix]);
+                }
+            }
+        }
+     else {
+        tIndexes Indexes;
+        Take(Bitmap, &Indexes, ColorFg, ColorBg);
+        for (int iy = 0; iy < Bitmap.height; iy++) {
+            const int lineStart = Bitmap.width * iy;
+            for (int ix = 0; ix < Bitmap.width; ix++) {
+                //SetIndex(x + ix, y + iy, Indexes[int(Bitmap.bitmap[lineStart + ix])]);
+                SetIndexFast(x + ix, y + iy, Indexes[int(Bitmap.bitmap[lineStart + ix])]);
+                }
+            }
+        }
+     UpdateDirty(x,y,x+Bitmap.Width()-1,y+Bitmap.height-1);
+     }
+}
+
+void cBitmap::DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap)
+{
+  if (bitmap && Bitmap.bitmap && Intersects(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1)) {
+     if (Covers(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+        Reset();
+     x -= x0;
+     y -= y0;
+     tIndexes Indexes;
+     Take(Bitmap, &Indexes, 0, 0);
+     for (int iy = 0; iy < Bitmap.height; iy++) {
+         tIndex index = Indexes[int(Bitmap.bitmap[iy])];
+         for (int ix = 0; ix < w; ix++) {
+             SetIndexFast(x + ix, y + iy, index);
+             }
+         }
+     }
+  UpdateDirty(x,y,x+w-1,y+Bitmap.height-1);
+}
+
+void cBitmap::DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap)
+{
+  if (bitmap && Bitmap.bitmap && Intersects(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1)) {
+     if (Covers(x, y, x + Bitmap.Width() - 1, y + Bitmap.Height() - 1))
+        Reset();
+     x -= x0;
+     y -= y0;
+     tIndexes Indexes;
+        Take(Bitmap, &Indexes, 0, 0);
+        for (int ix = 0; ix < Bitmap.width; ix++) {
+            tIndex index = Indexes[int(Bitmap.bitmap[ix])];
+            for (int iy = 0; iy < h; iy++) {
+                SetIndexFast(x + ix, y + iy, index);
+            }
+        }
+    }
+  UpdateDirty(x,y,x+Bitmap.width-1,y+h-1);
+#else
         for (int ix = 0; ix < Bitmap.width; ix++) {
             for (int iy = 0; iy < Bitmap.height; iy++) {
                 if (!Overlay || Bitmap.bitmap[Bitmap.width * iy + ix] != 0)
@@ -446,6 +514,7 @@ void cBitmap::DrawBitmap(int x, int y, c
             }
         }
      }
+#endif /* EHD */
 }
 
 void cBitmap::DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width, int Height, int Alignment)
@@ -507,6 +576,37 @@ void cBitmap::DrawRectangle(int x1, int 
      x2 = min(x2, width - 1);
      y2 = min(y2, height - 1);
      tIndex c = Index(Color);
+#ifdef USE_EHD
+     if (dirtyX1 > x1)  dirtyX1 = x1;
+     if (dirtyY1 > y1)  dirtyY1 = y1;
+     if (dirtyX2 < x2)  dirtyX2 = x2;
+     if (dirtyY2 < y2)  dirtyY2 = y2;
+
+     for (int y = y1; y <= y2; y++)
+         if (x2 >= x1)
+            memset(bitmap + y * width + x1, c, x2 - x1 + 1);
+     }
+}
+
+void cBitmap::DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV)
+{
+     if (bitmap && Intersects(x1, y1, x2, y2)) {
+        if (Covers(x1, y1, x2, y2))
+           Reset();
+     x1 -= x0;
+     y1 -= y0;
+     x2 -= x0;
+     y2 -= y0;
+     x1 = max(x1, 0);
+     y1 = max(y1, 0);
+     x2 = min(x2, width - 1);
+     y2 = min(y2, height - 1);
+     tIndex c = Index(Color);
+     if (dirtyX1 > x1)  dirtyX1 = x1;
+     if (dirtyY1 > y1)  dirtyY1 = y1;
+     if (dirtyX2 < x2)  dirtyX2 = x2;
+     if (dirtyY2 < y2)  dirtyY2 = y2;
+#endif /* EHD */
      for (int y = y1; y <= y2; y++)
          for (int x = x1; x <= x2; x++)
              SetIndex(x, y, c);
@@ -856,6 +956,20 @@ void cOsd::DrawBitmap(int x, int y, cons
       bitmaps[i]->DrawBitmap(x, y, Bitmap, ColorFg, ColorBg, ReplacePalette, Overlay);
 }
 
+#ifdef USE_EHD
+void cOsd::DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap)
+{
+  for (int i = 0; i < numBitmaps; i++)
+      bitmaps[i]->DrawBitmapHor(x, y, w, Bitmap);
+}
+
+void cOsd::DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap)
+{
+  for (int i = 0; i < numBitmaps; i++)
+      bitmaps[i]->DrawBitmapVert(x, y, h, Bitmap);
+}
+#endif /* EHD */
+
 void cOsd::DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width, int Height, int Alignment)
 {
   for (int i = 0; i < numBitmaps; i++)
@@ -868,6 +982,14 @@ void cOsd::DrawRectangle(int x1, int y1,
       bitmaps[i]->DrawRectangle(x1, y1, x2, y2, Color);
 }
 
+#ifdef USE_EHD
+void cOsd::DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV)
+{
+  for (int i = 0; i < numBitmaps; i++)
+      bitmaps[i]->DrawRectangle(x1, y1, x2, y2, Color, alphaGradH, alphaGradV, alphaGradStepH, alphaGradStepV);
+}
+#endif /* EHD */
+
 void cOsd::DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants)
 {
   for (int i = 0; i < numBitmaps; i++)
@@ -880,6 +1002,18 @@ void cOsd::DrawSlope(int x1, int y1, int
       bitmaps[i]->DrawSlope(x1, y1, x2, y2, Color, Type);
 }
 
+#ifdef USE_EHD
+void cOsd::DrawImage(u_int imageId, int x, int y, bool blend, int horRepeat, int vertRepeat) // GT: True color support.
+{
+    // No implementation.
+}
+
+void cOsd::SetImagePath(u_int imageId, char const *path) // GT: True color support.
+{
+    // No implementation.
+}
+#endif /* EHD */
+
 void cOsd::Flush(void)
 {
 }
@@ -902,6 +1036,13 @@ cOsdProvider::~cOsdProvider()
   osdProvider = NULL;
 }
 
+#ifdef USE_EHD
+cOsd *cOsdProvider::CreateTrueColorOsd(int Left, int Top, uint Level) // GT: True color support.
+{
+    return CreateOsd(Left, Top, Level);
+}
+#endif /* EHD */
+
 cOsd *cOsdProvider::NewOsd(int Left, int Top, uint Level)
 {
   if (Level == OSD_LEVEL_DEFAULT && cOsd::IsOpen())
@@ -945,6 +1086,33 @@ void cOsdProvider::UpdateOsdSize(bool Fo
      }
 }
 
+#ifdef USE_EHD
+cOsd *cOsdProvider::NewTrueColorOsd(int Left, int Top, int Random, uint Level, bool dontHide) // GT: True color osd support.
+{
+  if (Random) {
+     //  Left+=(rand()%Random)-(Random/2);
+     //  Top+=(rand()%Random)-(Random/2);
+     Left+=(rand()%10)-(10/2);
+     Top+=(rand()%20)-(20/2);
+     }
+  if (Level == OSD_LEVEL_DEFAULT && cOsd::IsOpen())
+     esyslog("ERROR: attempt to open OSD while it is already open - using dummy OSD!");
+  else if (osdProvider) {
+     cOsd *ActiveOsd = cOsd::Osds.Size() ? cOsd::Osds[0] : NULL;
+     cOsd *Osd = osdProvider->CreateTrueColorOsd(Left, Top, Level);
+     if (Osd == cOsd::Osds[0]) {
+        if (ActiveOsd)
+           ActiveOsd->SetActive(false);
+        Osd->SetActive(true);
+        }
+     return Osd;
+     }
+  else
+     esyslog("ERROR: no OSD provider available - using dummy OSD!");
+  return new cOsd(Left, Top, 999); // create a dummy cOsd, so that access won't result in a segfault
+}
+#endif /* EHD */
+
 void cOsdProvider::Shutdown(void)
 {
   delete osdProvider;
diff -ruNp vdr-1.7.7-extensions/osd.h vdr-1.7.7-ext-reelbox7/osd.h
--- vdr-1.7.7-extensions/osd.h	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/osd.h	2009-05-04 21:22:59.000000000 +0200
@@ -26,6 +26,9 @@ enum {
                    //AARRGGBB
   clrTransparent = 0x00000000,
   clrGray50      = 0x7F000000, // 50% gray
+#ifdef USE_EHD
+  clrGray62      = 0xA0000000, // 62% gray
+#endif /* EHD */
   clrBlack       = 0xFF000000,
   clrRed         = 0xFFFC1414,
   clrGreen       = 0xFF24FC24,
@@ -156,6 +159,16 @@ public:
        ///< contents of the bitmap will be lost. If Width and Height are the same
        ///< as the current values, nothing will happen and the bitmap remains
        ///< unchanged.
+#ifdef USE_EHD
+  inline void SetSizeWithoutRealloc(int Width, int Height) {
+     width = Width;
+     height = Height;
+     dirtyX1 = 0;
+     dirtyY1 = 0;
+     dirtyX2 = width - 1;
+     dirtyY2 = height - 1;
+     }
+#endif /* EHD */
   bool Contains(int x, int y) const;
        ///< Returns true if this bitmap contains the point (x, y).
   bool Covers(int x1, int y1, int x2, int y2) const;
@@ -185,6 +198,21 @@ public:
   void SetIndex(int x, int y, tIndex Index);
        ///< Sets the index at the given coordinates to Index.
        ///< Coordinates are relative to the bitmap's origin.
+#ifdef USE_EHD
+  inline void SetIndexFast(int x, int y, tIndex Index) {
+     if (bitmap)
+        if (0 <= x && x < width && 0 <= y && y < height)
+           bitmap[width * y + x] = Index;
+     }
+       ///< Sets the index at the given coordinates to Index.
+       ///< Coordinates are relative to the bitmap's origin. Does not update dirty-area.
+  void UpdateDirty(int x1, int y1, int x2, int y2) {
+     if (dirtyX1 > x1)  dirtyX1 = x1;
+     if (dirtyY1 > y1)  dirtyY1 = y1;
+     if (dirtyX2 < x2)  dirtyX2 = x2;
+     if (dirtyY2 < y2)  dirtyY2 = y2;
+     }
+#endif /* EHD */
   void DrawPixel(int x, int y, tColor Color);
        ///< Sets the pixel at the given coordinates to the given Color, which is
        ///< a full 32 bit ARGB value.
@@ -199,6 +227,10 @@ public:
        ///< area shall have its palette replaced with the one from Bitmap.
        ///< If Overlay is true, any pixel in Bitmap that has color index 0 will
        ///< not overwrite the corresponding pixel in the target area.
+#ifdef USE_EHD
+  void DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap);
+  void DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap);
+#endif /* EHD */
   void DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width = 0, int Height = 0, int Alignment = taDefault);
        ///< Draws the given string at coordinates (x, y) with the given foreground
        ///< and background color and font. If Width and Height are given, the text
@@ -210,6 +242,15 @@ public:
        ///< (x2, y2) corners with the given Color. If the rectangle covers the entire
        ///< bitmap area, the color palette will be reset, so that new colors can be
        ///< used for drawing.
+#ifdef USE_EHD
+  void DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV); //TB
+       ///< Draws a filled rectangle defined by the upper left (x1, y1) and lower right
+       ///< (x2, y2) corners with the given Color. If the rectangle covers the entire
+       ///< bitmap area, the color palette will be reset, so that new colors can be
+       ///< used for drawing.
+       ///< //TB: The Alpha-Value is incremented all alphaGradStepH pixels by the value AlphaGradH in every line,
+       ///< and all alphaGradStepV pixels by the value alphaGradV in every row.
+#endif /* EHD */
   void DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants = 0);
        ///< Draws a filled ellipse defined by the upper left (x1, y1) and lower right
        ///< (x2, y2) corners with the given Color. Quadrants controls which parts of
@@ -267,7 +308,9 @@ private:
   cBitmap *savedRegion;
   cBitmap *bitmaps[MAXOSDAREAS];
   int numBitmaps;
+#ifndef USE_EHD
   int left, top, width, height;
+#endif /* EHD */
   uint level;
   bool active;
 protected:
@@ -298,6 +341,9 @@ protected:
 public:
   virtual ~cOsd();
        ///< Shuts down the OSD.
+#ifdef USE_EHD
+  int left, top, width, height;
+#endif /* EHD */
   static int OsdLeft(void) { return osdLeft ? osdLeft : Setup.OSDLeft; }
   static int OsdTop(void) { return osdTop ? osdTop : Setup.OSDTop; }
   static int OsdWidth(void) { return osdWidth ? osdWidth : Setup.OSDWidth; }
@@ -323,7 +369,11 @@ public:
        ///< a single color combination, and may not be able to serve all
        ///< requested colors. By default the palette assumes there will be
        ///< 10 fixed colors and 10 color combinations.
+#ifdef USE_EHD
+  virtual cBitmap *GetBitmap(int Area);
+#else
   cBitmap *GetBitmap(int Area);
+#endif /* EHD */
        ///< Returns a pointer to the bitmap for the given Area, or NULL if no
        ///< such bitmap exists.
   virtual eOsdError CanHandleAreas(const tArea *Areas, int NumAreas);
@@ -368,15 +418,30 @@ public:
        ///< area shall have its palette replaced with the one from Bitmap.
        ///< If Overlay is true, any pixel in Bitmap that has color index 0 will
        ///< not overwrite the corresponding pixel in the target area.
+#ifdef USE_EHD
+  virtual void DrawBitmapHor(int x, int y, int w, const cBitmap &Bitmap);
+  virtual void DrawBitmapVert(int x, int y, int h, const cBitmap &Bitmap);
+#endif /* EHD */
   virtual void DrawText(int x, int y, const char *s, tColor ColorFg, tColor ColorBg, const cFont *Font, int Width = 0, int Height = 0, int Alignment = taDefault);
        ///< Draws the given string at coordinates (x, y) with the given foreground
        ///< and background color and font. If Width and Height are given, the text
        ///< will be drawn into a rectangle with the given size and the given
        ///< Alignment (default is top-left). If ColorBg is clrTransparent, no
        ///< background pixels will be drawn, which allows drawing "transparent" text.
+#ifdef USE_EHD
+  virtual void DrawImage(u_int imageId, int x, int y, bool blend, int horRepeat = 1, int vertRepeat = 1); // GT: True color support.
+       ///< Draws a 32-Bit true color image at (x, y) (upper left).
+#endif /* EHD */
   virtual void DrawRectangle(int x1, int y1, int x2, int y2, tColor Color);
        ///< Draws a filled rectangle defined by the upper left (x1, y1) and lower right
        ///< (x2, y2) corners with the given Color.
+#ifdef USE_EHD
+  virtual void DrawRectangle(int x1, int y1, int x2, int y2, tColor Color, int alphaGradH, int alphaGradV, int alphaGradStepH, int alphaGradStepV); //TB
+       ///< Draws a filled rectangle defined by the upper left (x1, y1) and lower right
+       ///< (x2, y2) corners with the given Color.
+       ///< //TB: The Alpha-Value is incremented all alphaGradStepH pixels by the value AlphaGradH in every line,
+       ///< and all alphaGradStepV pixels by the value alphaGradV in every row.
+#endif /* EHD */
   virtual void DrawEllipse(int x1, int y1, int x2, int y2, tColor Color, int Quadrants = 0);
        ///< Draws a filled ellipse defined by the upper left (x1, y1) and lower right
        ///< (x2, y2) corners with the given Color. Quadrants controls which parts of
@@ -401,6 +466,10 @@ public:
        ///< 7: vertical,   falling, upper
   virtual void Flush(void);
        ///< Actually commits all data to the OSD hardware.
+#ifdef USE_EHD
+  virtual void SetImagePath(u_int imageId, char const *path); // GT: True color support.
+       ///< Set the path of an image to be user later with DrawImage().
+#endif /* EHD */
 #ifdef USE_PINPLUGIN
   static bool pinValid;
 #endif /* PINPLUGIN */
@@ -419,6 +488,9 @@ protected:
   virtual cOsd *CreateOsd(int Left, int Top, uint Level) = 0;
       ///< Returns a pointer to a newly created cOsd object, which will be located
       ///< at the given coordinates.
+#ifdef USE_EHD
+  virtual cOsd *CreateTrueColorOsd(int Left, int Top, uint Level); // GT: True color support.
+#endif /* EHD */
 public:
   cOsdProvider(void);
       //XXX maybe parameter to make this one "sticky"??? (frame-buffer etc.)
@@ -434,6 +506,9 @@ public:
       ///< font sizes accordingly. If Force is true, all settings are recalculated,
       ///< even if the video resolution hasn't changed since the last call to
       ///< this funtion.
+#ifdef USE_EHD
+  static cOsd *NewTrueColorOsd(int Left, int Top, int Random, uint Level = OSD_LEVEL_DEFAULT, bool dontHide = false); // GT: True color osd support.
+#endif /* EHD */
   static void Shutdown(void);
       ///< Shuts down the OSD provider facility by deleting the current OSD provider.
   };
diff -ruNp vdr-1.7.7-extensions/reelboxbase.c vdr-1.7.7-ext-reelbox7/reelboxbase.c
--- vdr-1.7.7-extensions/reelboxbase.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/reelboxbase.c	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,29 @@
+#ifdef USE_EHD
+/***************************************************************************
+ *   Copyright (C) 2005 by Reel Multimedia                                 *
+ *                                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+// ReelboxBase.c
+
+#include "reelboxbase.h"
+
+
+cReelBoxBase *cReelBoxBase::reelbox = 0;  
+   
+#endif /* EHD */
diff -ruNp vdr-1.7.7-extensions/reelboxbase.h vdr-1.7.7-ext-reelbox7/reelboxbase.h
--- vdr-1.7.7-extensions/reelboxbase.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/reelboxbase.h	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,60 @@
+#ifdef USE_EHD
+/***************************************************************************
+ *   Copyright (C) 2005 by Reel Multimedia                                 *
+ *                                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+// ReelboxBase.h
+
+#ifndef REEL_BOX_BASE_H
+#define REEL_BOX_BASE_H
+#include "tools.h"
+#include <stdio.h>
+
+class cReelBoxBase 
+{   
+private:
+    static cReelBoxBase *reelbox;  
+    cReelBoxBase(const cReelBoxBase &ReelBoxBase);
+    cReelBoxBase &operator=(const cReelBoxBase &ReelBoxBase);
+
+public:    
+    virtual void PlayPipVideo(const unsigned char *Data, int Length){
+    printf("-------------cReelBoxBase::PlayPipVideo-----------------\n");
+    };
+    virtual void StartPip(bool start){ printf("virtual void StartPip"); };
+    virtual void SetPipDimensions(const uint x, const uint y, const uint width, const uint height){};
+    virtual void ChannelSwitchInLiveMode(){ printf("virtual void ChannelSwitchInLiveMode"); };
+    static cReelBoxBase* Instance();
+    
+protected: 
+    cReelBoxBase();
+};
+
+inline cReelBoxBase::cReelBoxBase()
+{
+    reelbox = this;
+}
+
+inline cReelBoxBase* cReelBoxBase::Instance()
+{
+    return reelbox;
+}    
+
+#endif // P__REEL_BOX_BASE_H
+#endif /* EHD */
diff -ruNp vdr-1.7.7-extensions/resumeDvd.c vdr-1.7.7-ext-reelbox7/resumeDvd.c
--- vdr-1.7.7-extensions/resumeDvd.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/resumeDvd.c	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,257 @@
+#ifdef USE_EHD
+// resume DB
+
+#include "resumeDvd.h"
+#include "tools.h"
+#include <stdio.h>
+
+const time_t cResumeInfo::ExpireTime = 604800; //7*24*3600; // 1 week in seconds
+
+/// class cResumeInfo -----------------------------------------------------------------
+cResumeInfo::cResumeInfo()
+{
+	Init();
+}
+		
+cResumeInfo::cResumeInfo(std::string line)
+{
+	if (!FromString(line))
+		Init();
+}
+		
+void cResumeInfo::Init()
+{
+	lastSeen = time(NULL); // now
+	titleChapter.clear();
+}
+		
+std::string cResumeInfo::ToString()
+{
+	std::stringstream os;
+	os <<titleChapter<<" "<<lastSeen;
+			
+	return os.str();
+}
+		
+bool cResumeInfo::FromString(std::string line)
+{
+			//1.33 1236347970
+	size_t idx = line.find(" ");
+	if (idx == std::string::npos) return false;
+			
+	titleChapter = line.substr(0,idx);
+			
+			// parse for time
+	line = line.substr(idx+1);
+	if (line.length()>0)
+		lastSeen = atol(line.c_str());
+	else
+		lastSeen = time(NULL);
+	return true;
+}
+		
+bool cResumeInfo::Expired()
+{
+	return time(NULL) > (lastSeen + ExpireTime);
+}
+
+
+/// class cResumeDvd --------------------------------------------------------------------
+cResumeDvd::cResumeDvd (std::string fileName)
+{
+    DvdList_.clear ();
+    currDvdId_.clear ();
+    fileName_ = fileName;
+    //Read ();
+}
+
+cResumeDvd::~cResumeDvd ()
+{
+    DvdList_.clear ();
+}
+
+//makes no entry in the list
+
+bool cResumeDvd::SetCurrentDvd (std::string dvdId)
+{
+    currDvdId_ = dvdId;
+    return DvdList_.find (dvdId) != DvdList_.end (); // is it present in the list ?
+}
+
+// sets title chapter of current DVD
+
+bool cResumeDvd::SetTitleChapter (std::string titleChapter)
+{
+    if (currDvdId_.length () > 0)
+    {
+            DvdList_[currDvdId_].titleChapter = titleChapter;
+	    DvdList_[currDvdId_].lastSeen = time(NULL);
+            Save ();
+            return true;
+    }
+
+    return false;
+}
+
+// get title and chapter of current DVD
+
+std::string cResumeDvd::TitleChapter ()
+{
+    return DvdList_[currDvdId_].titleChapter;
+}
+
+bool cResumeDvd::Read ()
+{
+    // discard current list and reload from file
+    // loose all unsave information
+    esyslog(*cString::sprintf("'%s': reading '%s'", __PRETTY_FUNCTION__, fileName_.c_str()));
+    FILE *fp = fopen (fileName_.c_str (), "r");
+    if (!fp) return false;
+    // clear list
+    DvdList_.clear ();
+    char* line = NULL;
+    cReadLine ReadLine;
+    char *p = NULL;
+
+    while ((line = ReadLine.Read (fp)) != NULL)
+    {
+            p = strchr (line, '=');
+            if (p)
+            {
+                    *p = 0;
+		    cResumeInfo resumeInfo(std::string (p + 1 ? p + 1 : ""));
+		    if (!resumeInfo.Expired())
+		    {
+		    	DvdList_[line] = resumeInfo;
+                    	printf ("'%s' '%s'\n", line, p + 1 ? p + 1 : "");
+		    } 
+		    else
+			esyslog(*cString::sprintf("'%s':Expired : '%s' '%s'\n", __PRETTY_FUNCTION__, line, p + 1 ? p + 1 : ""));
+            }
+    }
+
+
+    fclose (fp);
+    return true;
+}
+
+bool cResumeDvd::Save ()
+{
+    //(over)write list to a file
+    FILE *fp = fopen (fileName_.c_str (), "w");
+    if (!fp) return false;
+
+    std::map<std::string, cResumeInfo>::iterator it;
+    for (it = DvdList_.begin (); it != DvdList_.end (); it++)
+	    if (!it->second.Expired()) // save only if resume data has not expired; ie. 1 week
+            	fprintf (fp, "%s=%s\n",
+                	     it->first.c_str (), it->second.ToString().c_str());
+    fclose (fp);
+    return true;
+}
+
+cResumeDvd ResumeDvd ("/etc/vdr/plugins/resumeDVD.list");
+
+
+
+// Get DVD Id of the dvd in /dev/dvd
+// dvd id is made by "dvdname+dvdserialnumber"
+#include <stdio.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+
+#ifndef DVD_VIDEO_LB_LEN
+#define DVD_VIDEO_LB_LEN 2048
+#endif
+
+#define MSG_OUT stdout
+
+// taken from function of the same name in 
+// xine-lib-1.1.8/src/input/libdvdnav/vm.c
+
+int dvd_read_name (char *name, const char *device)
+{
+    /* Because we are compiling with _FILE_OFFSET_BITS=64
+     * all off_t are 64bit.
+     */
+    off_t off;
+    int fd, i, idx = 0;
+    uint8_t data[DVD_VIDEO_LB_LEN];
+
+    /* Read DVD name */
+    fd = open (device, O_RDONLY);
+    if (fd > 0)
+    {
+            off = lseek (fd, 32 * (off_t) DVD_VIDEO_LB_LEN, SEEK_SET);
+            if (off == (32 * (off_t) DVD_VIDEO_LB_LEN))
+            {
+                    off = read (fd, data, DVD_VIDEO_LB_LEN);
+                    close (fd);
+                    if (off == ((off_t) DVD_VIDEO_LB_LEN))
+                    {
+
+                            /*title*/
+                            for (i = 25; i < 73; i++)
+                            {
+                                    if ((data[i] == 0)) break;
+                                    name[idx++] = ((data[i] > 32) && (data[i] < 127)) ? data[i] : ' ';
+                            }
+
+
+                            /*serial number*/
+                            for (i = 73; i < 89; i++)
+                            {
+                                    if ((data[i] == 0)) break;
+                                    name[idx++] = ((data[i] > 32) && (data[i] < 127)) ? data[i] : ' ';
+                            }
+
+                            /* Alternate title
+                            for(i=89; i < 128; i++ )
+                                 {
+                              if((data[i] == 0)) break;
+                              name[idx++] = ((data[i] > 32) && (data[i] < 127))?data[i]:' ';
+                                }
+                             */
+
+                    }
+                    else
+                    {
+                            fprintf (MSG_OUT, "libdvdnav: Can't read name block. Probably not a DVD-ROM device.\n");
+                            return 0;
+                    }
+            }
+            else
+            {
+                    fprintf (MSG_OUT, "libdvdnav: Can't seek to block %u\n", 32);
+                    return 0;
+            }
+            close (fd);
+    }
+    else
+    {
+            fprintf (MSG_OUT, "Opening dvd device FAILED\n");
+            return 0;
+    }
+    name[idx] = 0;
+    return 1;
+}
+
+std::string DvdId ()
+{
+    std::string id;
+    char *name = (char*) malloc (128 * sizeof (char));
+    if (dvd_read_name (name, "/dev/dvd"))
+    {
+            id = name;
+            printf ("\033[1:92m DVD id: '%s'\033[0m\n", name);
+    }
+    else id.clear ();
+
+    free (name);
+    return id;
+}
+
+
+#endif /* EHD */
diff -ruNp vdr-1.7.7-extensions/resumeDvd.h vdr-1.7.7-ext-reelbox7/resumeDvd.h
--- vdr-1.7.7-extensions/resumeDvd.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.7-ext-reelbox7/resumeDvd.h	2009-05-04 21:22:59.000000000 +0200
@@ -0,0 +1,60 @@
+#ifdef USE_EHD
+#ifndef _RESUMEDVD_H
+#define _RESUMEDVD_H
+
+#include <map>
+#include <string>
+#include <sstream>
+#include <stdlib.h>
+#include <time.h>
+
+class cResumeInfo
+{
+	public:
+		
+		time_t lastSeen;
+		std::string titleChapter;
+
+		static const time_t ExpireTime;// = 604800; //7*24*3600; // 1 week in seconds
+
+		cResumeInfo();
+		cResumeInfo(std::string line);
+		void Init();
+		std::string ToString();
+		bool FromString(std::string);
+		bool Expired();
+		
+};
+
+class cResumeDvd
+{
+private:
+    std::string fileName_;
+    std::string currDvdId_;
+    std::map<std::string, cResumeInfo> DvdList_;
+
+public:
+    cResumeDvd (std::string);
+    ~cResumeDvd ();
+    // loose all unsave information
+    bool Read ();
+
+    //(over)write list to a file
+    bool Save ();
+
+    //makes no entry in the list, just sets currDvdId_
+    bool SetCurrentDvd (std::string id);
+
+    // sets title chapter of current DVD
+    bool SetTitleChapter (std::string tc);
+
+    // get title and chapter of current DVD
+    std::string TitleChapter ();
+};
+
+extern cResumeDvd ResumeDvd;
+
+std::string DvdId ();
+
+#endif
+#endif /* EHD */
diff -ruNp vdr-1.7.7-extensions/vdr.c vdr-1.7.7-ext-reelbox7/vdr.c
--- vdr-1.7.7-extensions/vdr.c	2009-05-04 21:24:29.000000000 +0200
+++ vdr-1.7.7-ext-reelbox7/vdr.c	2009-05-04 21:22:59.000000000 +0200
@@ -649,6 +649,10 @@ int main(int argc, char *argv[])
      printf("  PLUGINPARAM %d\n", PLUGINPARAMPATCHVERSNUM);
 #endif /* PLUGINPARAM */
 
+#ifdef USE_EHD
+     printf("  EHD\n");
+#endif /* EHD */
+
 #ifdef USE_ROTOR
      printf("  ROTOR\n");
 #endif /* ROTOR */
