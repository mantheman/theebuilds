diff -Naur src/audio/plugins/mplayer.py src-new/audio/plugins/mplayer.py
--- src/audio/plugins/mplayer.py	2008-11-09 11:20:13.000000000 -0500
+++ src-new/audio/plugins/mplayer.py	2009-01-03 15:52:28.000000000 -0500
@@ -118,7 +118,10 @@
             filename = item.url
 
         # Build the MPlayer command
-        mpl = '--prio=%s %s -slave %s' % (config.MPLAYER_NICE, config.MPLAYER_CMD, config.MPLAYER_ARGS_DEF)
+        mpl = '--prio=%s %s -slave %s %s' % (config.MPLAYER_NICE,
+                                             config.MPLAYER_CMD,
+                                             config.MPLAYER_ARGS_DEF,
+                                             config.MPLAYER_AUDIO_ARGS)
 
         if config.DEBUG_CHILDAPP:
             mpl += ' -v'
diff -Naur src/video/plugins/mplayer.py src-new/video/plugins/mplayer.py
--- src/video/plugins/mplayer.py	2008-11-30 21:42:54.000000000 -0500
+++ src-new/video/plugins/mplayer.py	2009-01-03 15:58:43.000000000 -0500
@@ -352,11 +352,25 @@
         command += str('%(playlist)s' % args).split()
         command += ['%(url)s' % args]
 
+        if config.USE_EXTRA_PARAM == 'Y' :
+            try :
+                extra_file = open( config.EXTRA_PARAM_FILE, "r")
+                param = extra_file.readline().strip()
+                extra_file.close()
+                command += param.split(' ')
+                print 'Extra Param is: %s' % (param)
+            except IOError :
+                print 'Param file does not exist'
+
         _debug_(' '.join(command[1:]))
 
         #if plugin.getbyname('MIXER'):
             #plugin.getbyname('MIXER').reset()
 
+        if len(config.MPLAYER_PRE_CMD) > 2 :
+            #print "Running MPLAYER_PRE_CMD: %s" % config.MPLAYER_PRE_CMD
+            os.system(config.MPLAYER_PRE_CMD)
+
         rc.app(self)
         self.app = MPlayerApp(command, self)
         return None
@@ -373,6 +387,10 @@
             return
 
         self.app.stop('quit\n')
+        if len(config.MPLAYER_POST_CMD) > 2 :
+            print "Running MPLAYER_POST_CMD: %s" % config.MPLAYER_POST_CMD
+            os.system(config.MPLAYER_POST_CMD)
+
         rc.app(None)
         self.app = None
 
--- src/event.py.org	2010-12-26 23:20:37.621719970 -0500
+++ src/event.py	2010-12-26 23:20:50.232719970 -0500
@@ -168,6 +168,9 @@
 TV_GOTO_LIVE_PLAY      = Event('TV_GOTO_LIVE_PLAY')
 VIDEO_NEXT_FILLMODE    = Event('VIDEO_NEXT_FILLMODE')
 VIDEO_NEXT_AUDIOMODE   = Event('VIDEO_NEXT_AUDIOMODE')
+ASPECT                 = Event('ASPECT')
+Audio                  = Event('Audio')
+Sub                    = Event('Sub')
 
 #
 # Global playing events
@@ -367,6 +370,9 @@
     '7'         : INPUT_7,
     '8'         : INPUT_8,
     '9'         : INPUT_9,
+    'ASPECT'    : ASPECT,
+    'Audio'     : Audio,
+    'Sub'       : Sub,
     }
 
 VIDEO_EVENTS = {
--- src/tv/channels.py.org	2011-01-15 21:17:02.653954527 -0500
+++ src/tv/channels.py	2011-01-15 23:41:53.270216362 -0500
@@ -119,6 +119,85 @@
 
         return config.TV_VIDEO_GROUPS[group]
 
+    def getVideoType(self, chan):
+        """
+        Gets the VideoType used by this Freevo channel.
+        """
+        group = 0
+
+        for i in range(len(config.TV_CHANNELS)):
+            chan_info = config.TV_CHANNELS[i]
+            if chan_info[2] == chan:
+                try:
+                    group = chan_info[5]
+                except:
+                    # XXX: put a better exception here
+                    group = "broke"
+
+                break;
+
+        #print "The VideoType is: %s" % group
+        return group
+
+    def getFileSuffix(self, _suffix):
+        filename = ".mpg"
+        
+        try:
+            if _suffix.find('HD_MP') != -1 :
+               if  _suffix.find('MPG2p') != -1 :
+                   filename = config.TV_RECORDFILE_SUFFIX_DVB + '7'
+               elif  _suffix.find('MPG2i') != -1 :
+                   filename = config.TV_RECORDFILE_SUFFIX_DVB + '6'
+               elif _suffix.find('H264p') != -1 :
+                   filename = config.TV_RECORDFILE_SUFFIX_DVB + '2'
+               elif _suffix.find('H264i') != -1 :
+                   filename = config.TV_RECORDFILE_SUFFIX_DVB + '8'
+            elif _suffix.find('SD_MP') != -1 :
+               filename = config.TV_RECORDFILE_SUFFIX_DVB + '3'
+        except :
+            pass
+        print "----- FILE SUFFIX: " + filename
+        return filename        
+
+    def getDirectStream(self, chan):
+        """
+        Gets the VideoType used by this Freevo channel.
+        """
+        direct = 0
+
+        for i in range(len(config.TV_CHANNELS)):
+            chan_info = config.TV_CHANNELS[i]
+            if chan_info[2] == chan:
+                try:
+                    direct = chan_info[6]
+                except:
+                    # XXX: put a better exception here
+                    direct = 0
+
+                break;
+
+        #print "The VideoType is: %s" % direct
+        return direct
+	
+
+    def getDisplayName(self, chan):
+        """
+        Gets the VideoType used by this Freevo channel.
+        """
+        group = 0
+
+        for i in range(len(config.TV_CHANNELS)):
+            chan_info = config.TV_CHANNELS[i]
+
+            if chan_info[2] == chan:
+                try:
+                    group = chan_info[1]
+                except:
+                    # XXX: put a better exception here
+                    group = ""
+                break;
+        print "The DisplayName is: %s" % group
+        return group
 
     def chanUp(self, isplayer, app=None, app_cmd=None):
         """
@@ -315,6 +394,35 @@
 
         return tuner_id, chan_name, prog_info
 
+    def getChannelInfo2(self, showtime=True):
+        """Get program info for the current channel"""
+        _debug_('getChannelInfo(showtime=%r)' % (showtime,), 2)
+
+        tuner_id = self.getChannel()
+        chan_name = config.TV_CHANNELS[self.chan_index][1]
+        chan_id = config.TV_CHANNELS[self.chan_index][0]
+
+        print "-------"
+
+        print "+++++++"
+        channels = epg_xmltv.get_guide().get_programs(time.time(), time.time(), chan_id)
+
+        if channels and channels[0] and channels[0].programs:
+            if showtime:
+                start_s = time.strftime(config.TV_TIME_FORMAT, time.localtime(channels[0].programs[0].start))
+                stop_s = time.strftime(config.TV_TIME_FORMAT, time.localtime(channels[0].programs[0].stop))
+                ts = '(%s-%s)' % (start_s, stop_s)
+                prog_info = '%s %s' % (ts, channels[0].programs[0].title)
+                desc_info = channels[0].programs[0].desc
+            else:
+                prog_info = channels[0].programs[0].title
+                desc_info = channels[0].programs[0].desc
+        else:
+            prog_info = 'No info'
+            desc_info = 'No desc'
+
+        return chan_id, chan_name, prog_info, desc_info
+
 
     def getChannelInfoRaw(self):
         """Get program info for the current channel"""
--- src/tv/plugins/generic_record.py.org	2011-01-15 23:42:01.029941120 -0500
+++ src/tv/plugins/generic_record.py	2011-01-15 23:42:07.905697933 -0500
@@ -64,6 +64,7 @@
 
         _debug_('ACTIVATING GENERIC RECORD PLUGIN', DINFO)
 
+        self.current_vg = None
         self.fc = FreevoChannels()
         self.thread = Record_Thread()
         self.thread.setDaemon(1)
@@ -74,9 +75,28 @@
     def Record(self, rec_prog):
         vg = self.fc.getVideoGroup(rec_prog.tunerid, False)
 
+        __type = self.fc.getVideoType(rec_prog.tunerid)
+
         frequency = self.fc.chanSet(str(rec_prog.tunerid), False, 'record plugin')
 
-        rec_prog.filename = tv_util.getProgFilename(rec_prog)
+#        rec_prog.filename = tv_util.getProgFilename(rec_prog)
+
+        vg = self.current_vg = self.fc.getVideoGroup(rec_prog.tunerid, True)
+
+        self.rec_command = ('--prio=%s ' % config.RECORD_NICE )
+
+        print rec_prog
+
+        if vg.tuner_type == 'streamdev' :
+           rec_prog.tunerid = "%s:%s/%s" % (self.current_vg.vdev, self.current_vg.adev, rec_prog.tunerid) 
+           if __type.find('_XN') != -1 :
+               rec_prog.tunerid =  rec_prog.tunerid.replace('Extern', 'PES')
+           print "Recording http stream: %s" % (rec_prog.tunerid)
+
+        suffix = self.fc.getFileSuffix(__type)
+        rec_prog.filename = os.path.splitext(tv_util.getProgFilename(rec_prog))[0] + suffix
+
+        print "Recording filename:  %s" % (rec_prog.filename)
 
         cl_options = { 'channel'  : rec_prog.tunerid,
                        'frequency' : frequency,
@@ -91,12 +111,17 @@
                        'group-type' : vg.group_type
         }
 
-        if isinstance(config.VCR_CMD, str) or isinstance(config.VCR_CMD, unicode):
-            self.rec_command = config.VCR_CMD % cl_options
-        elif isinstance(config.VCR_CMD, list) or isinstance(config.VCR_CMD, tuple):
-            self.rec_command = []
-            for arg in config.VCR_CMD:
-                self.rec_command.append(arg % cl_options)
+        #if isinstance(config.VCR_CMD, str) or isinstance(config.VCR_CMD, unicode):
+        #    self.rec_command = config.VCR_CMD % cl_options
+        #elif isinstance(config.VCR_CMD, list) or isinstance(config.VCR_CMD, tuple):
+        #    self.rec_command = []
+        #    for arg in config.VCR_CMD:
+        #        self.rec_command.append(arg % cl_options)
+
+        if vg.tuner_type == 'streamdev' :
+            self.rec_command += config.VCR_CMD_HTTP % cl_options
+        if vg.tuner_type == 'dvb' :
+            self.rec_command += config.VCR_CMD_DVB % cl_options
 
         self.thread.mode     = 'record'
         self.thread.prog     = rec_prog
--- src/tv/plugins/dvb_atsc.py  1969-12-31 19:00:00.000000000 -0500
+++ src-new/tv/plugins/dvb_atsc.py      2009-01-03 15:56:52.000000000 -0500
@@ -0,0 +1,388 @@
+# -*- coding: iso-8859-1 -*-
+# -----------------------------------------------------------------------
+# dvb_atsc.py - implementation of a TV function using Xine TS
+# -----------------------------------------------------------------------
+#
+# Notes:
+# Todo:        
+#
+# -----------------------------------------------------------------------
+
+# Configuration file. Determines where to look for AVI/MP3 files, etc
+import config
+
+import time, os, stat
+
+import util    # Various utilities
+import osd     # The OSD class, used to communicate with the OSD daemon
+import rc      # The RemoteControl class.
+import event as em
+import childapp # Handle child applications
+from tv.channels import FreevoChannels
+import plugin
+import subprocess
+from subprocess import Popen, PIPE
+import os.path 
+
+# Set to 1 for debug output
+DEBUG = config.DEBUG
+
+TRUE = 1
+FALSE = 0
+
+# Create the OSD object
+osd = osd.get_singleton()
+
+class PluginInterface(plugin.Plugin):
+    """
+    Plugin to watch live tv with xine (timeshifting).
+    """
+    def __init__(self):
+        plugin.Plugin.__init__(self)
+
+        # create the object and register it
+        plugin.register(dvb_atsc(), plugin.TV)
+
+
+class dvb_atsc:
+    aspect_ratio = 0
+
+    app = None
+
+    __muted    = 0
+    __igainvol = 0
+    
+    def __init__(self):
+        self.tuner_chidx = 0    # Current channel, index into config.TV_CHANNELS
+        self.app_mode = 'tv'
+        self.fc = FreevoChannels()
+        self.current_vg = None
+        self.stream_url = None
+        self.stream_cmd = None
+        self.stream_pid = 0
+        self.stream_file = config.TV_RECORD_DIR + "temp_stream.mpg" 
+        self.seek_on = 0
+        self.save_rec = 0
+        self.channel_name = ""
+        self.channel_type = ""
+        self.aspect_r = 0
+
+    def change_channel(self, channel) :
+        self.fc.chanSet(channel)
+
+        if self.app :
+           Pass
+
+    def getMPlayerCmd(self, args) :
+	return '--prio=%s %s -fs %s -slave %s' % args
+
+    def getMPlayerArgs(self) :
+        return (config.MPLAYER_NICE, config.MPLAYER_CMD, config.MPLAYER_ARGS_DEF)
+
+    def getDvbArgs(self, is_sat, type, tuner_channel, direct_stream) :
+        args = ""
+        more_opts = ""
+
+	if is_sat == 'dvb' :
+                print 'Playing a local dvb:// stream'
+
+                self.stream_url = ('dvb://%s' % tuner_channel)
+	        #self.stream_cmd = ('mplayer -dumpstream -dumpfile /tmp/test.mpg %s' % self.stream_url)
+	        self.stream_cmd = None
+                args = ('%s %s %s' % (self.stream_url, config.MPLAYER_ARGS[type], more_opts), )
+                
+        if is_sat == 'streamdev' :
+                print 'Playing a vdr-streamdev stream'
+
+                self.stream_url = ('http://%s:%s/%s' % (self.current_vg.vdev, self.current_vg.adev, tuner_channel))
+                
+                if direct_stream == 1 :
+                    self.stream_cmd = None
+                    tmp = self.stream_url
+                else :
+                    self.stream_cmd = 'wget'
+                    tmp = self.stream_file
+
+                args = ('%s %s %s' % (more_opts, config.MPLAYER_ARGS[type], tmp), )
+        return args
+
+    def Play(self, mode, tuner_channel=None):
+
+        try:
+            channel = int(tuner_channel)
+        except ValueError:
+            channel = 0
+
+        if not tuner_channel:
+            tuner_channel = self.fc.getChannel()
+
+        vg = self.current_vg = self.fc.getVideoGroup(tuner_channel, True)
+        self.seek_on = 0
+        self.save_rec = 0
+        type = self.fc.getVideoType(tuner_channel)
+	direct_stream = self.fc.getDirectStream(tuner_channel)
+
+
+	print tuner_channel
+	print vg.vdev
+	print vg.adev
+	print vg.tuner_type
+       
+        self.stream_pid = 0
+        self.group_type = vg.group_type
+
+        self.channel_type = self.fc.getVideoType(tuner_channel)
+
+        if mode == 'tv':
+            if type.find('_MP') != -1 :
+                print 'Using MPlayer for Channel %s' % (tuner_channel)
+                command = self.getMPlayerCmd( self.getMPlayerArgs() + self.getDvbArgs( vg.tuner_type, type, tuner_channel, direct_stream) )
+
+            self.channel_name = self.fc.getDisplayName(tuner_channel)
+            #if channel >= 0:
+            self.fc.chanSet(tuner_channel, True)
+
+            tuner_id, chan_name, prog_info, desc_info = self.fc.getChannelInfo2(showtime=True)
+
+            if config.USE_EXTRA_PARAM == 'Y' :
+                try :
+                    extra_file = open( config.EXTRA_PARAM_FILE, "r")
+                    param = extra_file.readline()
+                    extra_file.close()
+                    command += ' ' + param
+                    print 'Extra Param is: %s' % (param)
+                except IOError :
+                    print 'Param file does not exist'
+        else:
+            print 'Mode "%s" is not implemented' % mode  # XXX ui.message()
+            return
+
+        opts = '%s' % self.stream_file
+
+        if len(config.MPLAYER_PRE_CMD) > 2 :
+            print "Running MPLAYER_PRE_CMD: %s" % config.MPLAYER_PRE_CMD
+            os.system(config.MPLAYER_PRE_CMD)
+
+        print 'cmd: %s' % (command)
+        if self.stream_cmd != None :
+            #self.stream_pid = subprocess.Popen([self.stream_cmd, '-O', self.stream_file, self.stream_url], stdout=PIPE)
+
+            #self.stream_pid = subprocess.Popen([self.stream_cmd, '-O', "-", self.stream_url], stdout=PIPE)
+            #self.stream_pid2 = subprocess.Popen(['/usr/bin/ts_filter', self.stream_file], stdin=self.stream_pid.stdout)
+
+            self.stream_pid = subprocess.Popen([self.stream_cmd, '-O', '-', self.stream_url], stdout=PIPE)
+            self.stream_pid2 = subprocess.Popen(['/usr/bin/ffmpeg', '-y','-i', '-', '-acodec', 'copy', '-vcodec', 'copy', '-f', 'matroska', self.stream_file], stdin=self.stream_pid.stdout)
+            #self.stream_pid2 = subprocess.Popen(['/usr/bin/ffmpeg', '-y','-i', '-', '-acodec', 'copy', '-vcodec', 'copy', '-f', 'matroska', self.stream_file, '-newaudio'], stdin=self.stream_pid.stdout)
+
+
+            print 'stream pid: %d' % self.stream_pid.pid
+
+            print tuner_id
+            print chan_name
+            print prog_info
+            print desc_info
+
+	    self.hasosd = 0
+
+            if os.path.exists(config.TVOSDSCRIPT) :
+                self.hasosd = 1
+
+            if self.hasosd :
+                top_text = '%s - %s' % (chan_name, prog_info)
+                logofile = '%s/%s.png' % (config.TVLOGOS, tuner_id)
+
+                print "LOGOFILE: %s" % logofile
+
+                if not os.path.exists(logofile) :
+                    logofile='none'
+
+                subprocess.Popen([config.TVOSDSCRIPT, top_text, desc_info, config.TVOSDIMAGE, logofile, '/tmp/chaninfo.jpg'], stdin=self.stream_pid.stdout)
+
+            count = 0
+            while not os.path.exists(self.stream_file) :
+                if count % 4 == 0 : 
+                    print 'Waiting for streaming file: %d' % (count/4)
+                count += 1
+                time.sleep(.250)
+                if count > (4*8) : 
+                    print "Waited for streaminf file, not waiting any longer"
+                    break;
+
+            if type.find('_SD_') != -1 :
+                buf_size = config.LIVE_MIN_BUF_SDTV
+            elif type.startswith('H264'):
+                buf_size = config.LIVE_MIN_BUF_H264
+            else :
+                buf_size = config.LIVE_MIN_BUF_HDTV
+
+            print "Wait Buf Size: %d" % buf_size
+            count = 0
+            tmp_size = 0
+            last_size = 0
+
+            while os.path.exists(self.stream_file) and os.stat(self.stream_file)[stat.ST_SIZE] < buf_size :
+                print "Interm Size: %d" % os.stat(self.stream_file)[stat.ST_SIZE]
+                time.sleep(.200)
+                tmp_size = os.stat(self.stream_file)[stat.ST_SIZE]  
+                if tmp_size == last_size :
+                   count += 1
+                else :
+                  last_size = tmp_size
+                if count > 75 :
+                   print "Waited for stream, not waiting any longer"
+                   break
+
+            if os.path.exists(self.stream_file) :
+                print "Final Size: %d" % os.stat(self.stream_file)[stat.ST_SIZE]
+
+            if os.path.exists(self.stream_file) and os.stat(self.stream_file)[stat.ST_SIZE] < buf_size :
+                print "Size is: %d, returning" % os.stat(self.stream_file)[stat.ST_SIZE]
+                if self.stream_pid != 0 :
+                    print "Killing PID: %d" % self.stream_pid.pid
+                    #self.stream_pid.kill()
+                    #self.stream_pid2.kill()
+                    tmp = '%d' % self.stream_pid.pid
+                    os.spawnlp(os.P_WAIT, 'kill', 'kill', tmp)
+                    try :
+                        os.remove(self.stream_file)
+                    except OSError :
+                        pass
+        self.mode = mode
+        self.osdpid = 0
+        # Start up the TV task
+        self.app = childapp.ChildApp2(command)
+        
+        self.prev_app = rc.app()
+        rc.app(self)
+
+        if osd.focused_app():
+            osd.focused_app().hide()
+        if DEBUG: print '%s: started %s app' % (time.time(), self.mode)
+
+        if self.hasosd :
+           self.osdpid = subprocess.Popen(['/usr/bin/mplayer', '-ontop', '-geometry', config.TVOSDGEO, '-vo', config.TVOSDVO, 'mf:///tmp/chaninfo.jpg', '-mf', 'fps=60', '-loop', config.TVOSDTIME])
+        
+    def Stop(self, channel_change=0):
+        self.app.stop('quit\n')
+
+        rc.app(self.prev_app)
+        if osd.focused_app() and not channel_change:
+            osd.focused_app().show()
+
+        if os.path.exists('/tmp/freevo.wid'): os.unlink('/tmp/freevo.wid')
+
+
+    def eventhandler(self, event, menuw=None):
+        s_event = '%s' % event
+
+        #print "EVEN: %s .. %s" % (s_event, event) 
+        if event == em.STOP or event == em.PLAY_END:
+            print "STOP"
+
+            if self.channel_type.find('_MP') != -1 :
+                if len(config.MPLAYER_POST_CMD) > 2 :
+                   #print "Running MPLAYER_POST_CMD: %s" % config.MPLAYER_POST_CMD
+                   os.system(config.MPLAYER_POST_CMD)
+
+            if self.stream_pid != 0 :
+                #print "Killing PID: %d" % self.stream_pid.pid
+                tmp = '%d' % self.stream_pid.pid
+                os.spawnlp(os.P_WAIT, 'kill', 'kill', tmp)
+                if self.save_rec == 0 :
+                    try :
+                       os.remove(self.stream_file)
+                    except OSError :
+                       pass
+                else :
+                    file_suffix = self.fc.getFileSuffix(self.channel_type)
+                    new_file = config.TV_RECORD_DIR + self.channel_name + "_" + time.strftime("%m_%d_%y_%H:%M:%S")  + file_suffix
+                    #print "Renaming file to: %s" % new_file
+                    os.rename(self.stream_file, new_file);
+
+            self.Stop()
+            rc.post_event(em.PLAY_END)
+            return TRUE
+
+	if event == em.PLAY or event == em.PAUSE:
+            self.app.write('pause\n')
+            return True
+
+        if event == em.ASPECT:
+           if self.aspect_r == 0 :
+              print "switch_ratio:  1.33"
+              self.app.write('switch_ratio 1.3333\n')
+              self.aspect_r = 1
+              return True
+
+           if self.aspect_r == 1 :
+              print "switch_ratio:  1.44"
+              self.app.write('switch_ratio 1.4444\n')
+              self.aspect_r = 2
+              return True
+
+           if self.aspect_r == 2 :
+              print "switch_ratio:  1.55"
+              self.app.write('switch_ratio 1.5555\n')
+              self.aspect_r = 3
+              return True
+
+           if self.aspect_r == 3 :
+              print "switch_ratio:  1.66"
+              self.app.write('switch_ratio 1.6666\n')
+              self.aspect_r = 4
+              return True
+
+           if self.aspect_r == 4 :
+              print "switch_ratio:  1.77"
+              self.app.write('switch_ratio 1.7777\n')
+              self.aspect_r = 0
+           return True
+
+        if event == em.TOGGLE_OSD:
+            if self.hasosd :
+                try :
+                    pid, sts = os.waitpid(self.osdpid.pid, os.WNOHANG)
+                except OSErrorr :
+                    pid = 1
+
+                if pid != 0 :
+	           self.osdpid = subprocess.Popen(['/usr/bin/mplayer', '-ontop', '-geometry', config.TVOSDGEO, '-vo', config.TVOSDVO, 'mf:///tmp/chaninfo.jpg', '-mf', 'fps=60', '-loop', config.TVOSDTIME])
+            else :
+                self.app.write('osd\n')
+
+            return TRUE
+
+        if s_event.startswith('INPUT_') :
+            if DEBUG: print "INPUT: ", int( s_event[6])
+            tmpevent = int(s_event[6]) 
+
+            if tmpevent == 1 :
+               self.app.write('audio_delay 0.100\n')
+
+            if tmpevent == 2 :
+               self.app.write('audio_delay -0.100\n')
+
+            if tmpevent == 9 :
+               print 'Not deleting'
+               if self.save_rec == 0 :
+                   self.app.write('osd_show_text "%s"\n' % _('Saving recording'))
+                   self.save_rec = 1
+               else :
+                   self.app.write('osd_show_text "%s"\n' % _('NOT Saving recording'))
+                   self.save_rec = 0
+                
+            return TRUE     
+
+        if event == em.Audio:
+            self.app.write('switch_audio\n')
+
+        if event == em.Sub:
+            self.app.write('sub_visibility\n')
+
+        if event == em.SEEK:
+            pos = int(event.arg)
+            action='seek '
+            self.app.write('%s%s\n' % (action, pos) )
+            return True
+        return FALSE
+    
