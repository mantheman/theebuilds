--- Makefile.org    2013-01-24 15:00:30.297355466 -0500
+++ Makefile    2013-01-24 15:10:12.356357516 -0500
@@ -412,6 +412,11 @@
               sub/vobsub.c \
               timeline/tl_edl.c \
               timeline/tl_matroska.c \
+              stream/etp/mpegts.c \
+              stream/etp/bitstream.c \
+              stream/etp/protocol.c \
+              stream/etp/utils.c \
+              stream/stream_etp.c \
               $(SRCS_COMMON-yes) \
               $(SRCS_COMMON-NEGATED-no)
 
diff -Naur stream.org/stream_etp.c stream/stream_etp.c
--- stream.org/stream_etp.c	1969-12-31 19:00:00.000000000 -0500
+++ stream/stream_etp.c	2013-03-18 01:00:27.047841925 -0400
@@ -0,0 +1,831 @@
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <math.h>
+#include <time.h>
+
+#include "mp_msg.h"
+#include "stream.h"
+#include "m_option.h"
+#include "m_struct.h"
+#include "tcp.h"
+#include "etp/utils.h"
+#include "etp/protocol.h"
+#include "etp/mpegts.h"
+#include "etp/bitstream.h"
+
+#define SEEK_MAX_COUNT		500000
+#define LIVE_POS			0xFFFFFFFFFFFFFFFF
+#define SEEK_FILL_SZ2		(188 * 80)
+
+FILE *debug_fp = NULL;
+
+static struct stream_priv_s
+{
+	char* host;
+	int port;
+	char* filename;
+	int handle;
+	uint8_t id;
+	uint8_t is_seeking;
+	time_t last_timeend_send;
+	double last_timeend;
+
+	uint64_t last_timeend_send_ms;
+//	double last_timeend_send;
+} stream_priv_dflts;
+
+#define ST_OFF(f) M_ST_OFF(struct stream_priv_s,f)
+
+/// URL definition
+static const m_option_t stream_opts_fields[] =
+{
+	{"hostname", ST_OFF(host), CONF_TYPE_STRING, 0, 0 ,0, NULL},
+	{"port", ST_OFF(port), CONF_TYPE_INT, 0, 0 ,65635, NULL},
+	{"filename", ST_OFF(filename), CONF_TYPE_STRING, 0, 0 ,0, NULL},
+	{ NULL, NULL, 0, 0, 0, 0,  NULL }
+};
+
+static const struct m_struct_st stream_opts =
+{
+	"etp",
+	sizeof(struct stream_priv_s),
+	&stream_priv_dflts,
+	stream_opts_fields
+};
+
+static int etp_connect(struct stream_priv_s *p)
+{
+	uint8_t _req[100] = {0};
+	p->handle = connect2Server(p->host, p->port, 0);
+
+	if (p->handle > 0)
+	{
+		int s=0;
+		uint8_t a=0xFF;
+
+		sprintf(_req, PROTOCOL_INIT_STR);
+		s = send(p->handle, _req, strlen(_req), DEFAULT_SEND_FLAGS);
+
+		if (s <= 0)
+		{
+			mp_msg(MSGT_OPEN,MSGL_ERR, "[etp] etp_connect, write error (1): %s\n",strerror(errno));
+			closesocket(p->handle);
+			return -1;
+		}
+
+		if (recv(p->handle, &a, 1, 0) <= 0)
+		{
+			mp_msg(MSGT_OPEN,MSGL_ERR, "[etp] etp_connect, write error (2): %s\n",strerror(errno));
+			closesocket(p->handle);
+			return -1;
+		}
+
+		if (!(a == PROTOCOL_INIT_GOOD))
+		{
+			closesocket(p->handle);
+			p->handle = -1;
+		}
+	}
+
+	return p->handle;
+}
+
+static int fill_buffer(stream_t *s, char* buffer, int max_len)
+{
+//	printf("fill_buffer: %d\n", max_len);
+	if (s->fd > 0)
+		return recv(s->fd, buffer, max_len, 0);
+	return -1;
+}
+
+static int _flush_incoming_stream2(stream_t *s)
+{
+	int b = 0, rc;
+	uint8_t loop = 1;
+	uint8_t flush[188] = {0};
+	uint32_t sync_count = 0, packet_skip = 0;
+
+	ioctl (s->fd, FIONREAD, &b);
+	printf("_flush_incoming_stream2, start: %d\n", b);
+	if (debug_fp)
+	{
+		fprintf(debug_fp, "_flush_incoming_stream2, start: %d\n", b);
+		fflush(debug_fp);
+	}
+
+	while(loop)
+	{
+		ioctl (s->fd, FIONREAD, &b);
+		if (b < 188)
+		{
+			loop = 0;
+			continue;
+		}
+
+		if (select_wait(s->fd, 1, 0) == 0)
+			continue;
+
+		if (recv(s->fd, &flush[0], 1, 0))
+		{
+			if (flush[0] == 0x47)
+			{
+				if (select_wait(s->fd, 1, 0) == 0)
+					continue;
+
+				rc = recv(s->fd, &flush[1], 187, 0);
+				packet_skip++;
+/*
+				if (flush[1] == TS_NULL_PACKET[1] && flush[2] == TS_NULL_PACKET[2])
+				{
+					loop = 0;
+					packet_skip = rc;
+				}
+				else
+					packet_skip++;
+*/
+			}
+			else
+				sync_count++;
+		}
+		else
+		{
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "-- F Me\n");
+				fflush(debug_fp);
+			}
+			break;
+		}
+	}
+	ioctl (s->fd, FIONREAD, &b);
+	printf("_flush_incoming_stream2, end: %d (skip: %d)\n", b, packet_skip);
+	if (debug_fp)
+	{
+		fprintf(debug_fp, "_flush_incoming_stream2, end: %d (skip: %d)\n", b, packet_skip);
+		fflush(debug_fp);
+	}
+
+	return packet_skip;
+}
+
+static int _wait_incoming_stream(stream_t *s, int wait)
+{
+	int b = 0, rc, ret = -1;
+	uint8_t loop = 1;
+	uint8_t flush[188] = {0};
+	uint32_t sync_count = 0, packet_skip = 0;
+
+	if (select_wait(s->fd, wait, 0) < 0)
+	{
+		printf("NOOOOOOOOOO\n");
+		return -1;
+	}
+	while (b == 0)
+	{
+		rc = ioctl (s->fd, FIONREAD, &b);
+//		printf("_wait_incoming_stream, start: %d (rc=%d)\n", b, rc);
+		if (rc == -1)
+			printf("hhhhhh: %s\n", strerror(errno));
+		else if (b == 0)
+			usleep(250*1000);
+	}
+
+	if (recv(s->fd, flush, 1, 0))
+	{
+		int i = 0;
+//		printf("_wait_incoming_stream, 1 -- 1\n");
+
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_wait_incoming_stream, 1 -- 1\n");
+			fflush(debug_fp);
+		}
+
+		while(flush[0] != 0x47)
+		{
+			i++;
+//			printf("[%d] _wait_incoming_stream, syncing: 0x%x\n", i, flush[0]);
+
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "[%d] _wait_incoming_stream, syncing: 0x%x\n", i, flush[0]);
+				fflush(debug_fp);
+			}
+
+			rc = select_wait(s->fd, 0, 250*1000);
+			if (rc == 0)
+			{
+				printf("I iz sleeping\n");
+				continue;
+			}
+			else if (rc < 0)
+			{
+				printf("I iz sad1\n");
+				return -1;
+			}
+
+			if (recv(s->fd, flush, 1, 0) < 0)
+			{
+				printf("I iz sad2\n");
+				return -1;
+			}
+		}
+
+
+//		printf("_wait_incoming_stream, 1 -- 2\n");
+
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_wait_incoming_stream, 1 -- 2\n");
+			fflush(debug_fp);
+		}
+
+		while (select_wait(s->fd, wait, 0) == 0)
+		{
+			printf("huh?\n");
+		}
+
+		rc = recv(s->fd, &flush[1], 187, 0);
+//		printf("_wait_incoming_stream, 1 -- 3: %d\n", rc);
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_wait_incoming_stream, 1 -- 3: %d\n", rc);
+			fflush(debug_fp);
+		}
+
+		if (rc == 187)
+		{
+			ioctl (s->fd, FIONREAD, &b);
+//			printf("_wait_incoming_stream end2\n");
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "_wait_incoming_stream end2\n");
+				fflush(debug_fp);
+			}
+			ret = b;
+//			return b;
+		}
+		else
+		{
+			ioctl (s->fd, FIONREAD, &b);
+//			printf("flush broke1: %s %d -- %d\n", strerror(errno), errno, b);
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "flush broke1: %s %d\n", strerror(errno), errno);
+				fflush(debug_fp);
+			}
+			ret = b;
+//			return b;
+		}
+	}
+	else
+	{
+		printf("flush broke: %s %d\n", strerror(errno), errno);
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "flush broke: %s %d\n", strerror(errno), errno);
+			fflush(debug_fp);
+		}
+	}
+
+//	printf("_wait_incoming_stream end3\n");
+	if (debug_fp)
+	{
+		fprintf(debug_fp, "_wait_incoming_stream end3\n");
+		fflush(debug_fp);
+	}
+
+	ioctl (s->fd, FIONREAD, &b);
+//	printf("_wait_incoming_stream, end: %d\n", b);
+	return ret;
+}
+
+
+/*
+static int _flush_incoming_stream(stream_t *s, int flush_count)
+{
+	int rc = -1, bytes_in_socket=0, b;
+	uint8_t loop = 1, count = 0;
+	uint8_t flush[188] = {0};
+	uint32_t sync_count = 0, packet_skip = 0;
+	uint16_t pid = 0;
+	printf("_flush_incoming_stream start\n");
+
+	if (debug_fp)
+	{
+		fprintf(debug_fp, "_flush_incoming_stream start\n");
+		fflush(debug_fp);
+	}
+	do
+	{
+		rc = select_wait(s->fd, 1, 0);
+		count++;
+		if (count > 5)
+		{
+			rc = -1;
+			break;
+		}
+	}
+	while(rc == 0);
+
+	if (rc < 0)
+	{
+		printf("_flush_incoming_stream, error on select: %s %d\n", strerror(errno), errno);
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_flush_incoming_stream, error on select: %s %d\n", strerror(errno), errno);
+			fflush(debug_fp);
+		}
+		return -1;
+	}
+
+	loop = 1;
+
+	while(loop)
+	{
+		bytes_in_socket = -1;
+		rc = ioctl (s->fd, FIONREAD, &bytes_in_socket);
+		printf("_flush_incoming_stream, FIONREAD: %d (rc=%d)\n", bytes_in_socket, rc);
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_flush_incoming_stream, FIONREAD: %d (rc=%d)\n", bytes_in_socket, rc);
+			fflush(debug_fp);
+		}
+		if (flush_count == -1 && bytes_in_socket < 188)
+		{
+			printf("LOOP OUT\n");
+			loop = 0;
+			continue;
+		}
+		else
+		{
+			rc = select_wait(s->fd, 1, 0);
+			if (rc == 0)
+				continue;
+
+			do
+			{
+				rc = recv(s->fd, &flush[0], 1, 0);
+				if (rc == 1 && flush[0] == 0x47)
+				{
+					rc = recv(s->fd, &flush[1], 187, 0);
+					printf("Read: %d\n", rc);
+				}
+				else
+				{
+					if (rc > 0)
+					{
+						sync_count++;
+					}
+					else
+					{
+						printf("_flush_incoming_stream, error on getting packet: %s %d\n", strerror(errno), errno);
+						if (debug_fp)
+						{
+							fprintf(debug_fp, "_flush_incoming_stream, error on getting packet: %s %d\n", strerror(errno), errno);
+							fflush(debug_fp);
+						}
+						break;
+					}
+				}
+			}
+			while(flush[0] != 0x47);
+		}
+	}
+
+	if (flush_count == -1)
+	{
+		while(loop)
+		{
+			ioctl (s->fd, FIONREAD, &b);
+
+			if (b < 188)
+			{
+				loop = 0;
+				continue;
+			}
+
+			if (select_wait(s->fd, 1, 0) == 0)
+				continue;
+
+			if (recv(s->fd, &flush[0], 1, 0))
+			{
+				if (flush[0] == 0x47)
+				{
+					if (select_wait(s->fd, 1, 0) == 0)
+						continue;
+
+					rc = recv(s->fd, &flush[1], 187, 0);
+
+					if (flush[1] == TS_NULL_PACKET[1] && flush[2] == TS_NULL_PACKET[2])
+					{
+						loop = 0;
+						packet_skip = rc;
+					}
+					else
+						packet_skip++;
+				}
+				else
+					sync_count++;
+			}
+			else
+			{
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "-- F Me\n");
+					fflush(debug_fp);
+				}
+
+//				printf("F me\n");
+				break;
+			}
+		}
+		printf("_flush_incoming_stream end1\n");
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_flush_incoming_stream end1\n");
+			fflush(debug_fp);
+		}
+		return packet_skip;
+	}
+	else
+	{
+		if (select_wait(s->fd, 1, 0) == 0)
+		{
+			printf("NOOOOOOOOOO\n");
+		}
+		if (recv(s->fd, flush, 1, 0))
+		{
+			int i=0;
+			printf("_flush_incoming_stream, 1 -- 1\n");
+
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "_flush_incoming_stream, 1 -- 1\n");
+				fflush(debug_fp);
+			}
+
+			while(flush[0] != 0x47)
+			{
+				printf("[%d] _flush_incoming_stream, syncing: 0x%x\n", i, flush[0]);
+
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "[%d] _flush_incoming_stream, syncing: 0x%x\n", i, flush[0]);
+					fflush(debug_fp);
+				}
+
+				if (recv(s->fd, flush, 1, 0) <= 0)
+					break;
+				i++;
+			}
+
+
+			if (flush[0] == 0x47)
+			{
+				printf("_flush_incoming_stream, 1 -- 2\n");
+
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "_flush_incoming_stream, 1 -- 2\n");
+					fflush(debug_fp);
+				}
+
+
+				rc = recv(s->fd, &flush[1], 187, 0);
+				printf("_flush_incoming_stream, 1 -- 3: %d\n", rc);
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "_flush_incoming_stream, 1 -- 3: %d\n", rc);
+					fflush(debug_fp);
+				}
+				if (rc == 187)
+				{
+					ioctl (s->fd, FIONREAD, &b);
+					printf("_flush_incoming_stream end2\n");
+					if (debug_fp)
+					{
+						fprintf(debug_fp, "_flush_incoming_stream end2\n");
+						fflush(debug_fp);
+					}
+					return b;
+				}
+			}
+			else
+			{
+				ioctl (s->fd, FIONREAD, &b);
+				printf("flush broke1: %s %d -- %d\n", strerror(errno), errno, b);
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "flush broke1: %s %d\n", strerror(errno), errno);
+					fflush(debug_fp);
+				}
+				return b;
+			}
+		}
+		else
+		{
+			printf("flush broke: %s %d\n", strerror(errno), errno);
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "flush broke: %s %d\n", strerror(errno), errno);
+				fflush(debug_fp);
+			}
+		}
+		printf("_flush_incoming_stream end3\n");
+		if (debug_fp)
+		{
+			fprintf(debug_fp, "_flush_incoming_stream end3\n");
+			fflush(debug_fp);
+		}
+		return -1;
+	}
+	return -1;
+}
+*/
+
+static int control(stream_t *s, int cmd, void *arg)
+{
+	uint8_t skipb=0;
+	struct stream_priv_s *priv = s->priv;
+	int p;
+	uint64_t pos = 0;
+
+
+	if (!(priv && priv->handle > 0))
+		return STREAM_UNSUPPORTED;
+
+	switch(cmd)
+	{
+		case STREAM_CTRL_GET_TIME_START:
+			if (priv->is_seeking == 1)
+			{
+				printf("GET_TIME_LEN, but seeking\n");
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "GET_TIME_LEN, but seeking\n");
+					fflush(debug_fp);
+				}
+				return STREAM_ERROR;
+			}
+
+			pos = -1;
+			while (pos == -1)
+			{
+				protocol_get_tuner_time_startpos(s->fd);
+				p = recv(priv->handle, &pos, sizeof(uint64_t), 0);
+			}
+
+			if ((int64_t)pos != -1)
+			{
+				*((double*)arg) = (double)pos/90000.0;
+				return STREAM_OK;
+			}
+		break;
+
+		case STREAM_CTRL_GET_TIME_LENGTH: // 1
+		{
+			uint64_t now_ms = get_time_ms();
+
+			if (priv->is_seeking == 1)
+			{
+				printf("GET_TIME_LEN, but seeking\n");
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "GET_TIME_LEN, but seeking\n");
+					fflush(debug_fp);
+				}
+				return STREAM_ERROR;
+			}
+
+//			printf("TD: %" PRIu64" %" PRIu64" = %" PRIu64"\n", now_ms, priv->last_timeend_send_ms, now_ms - priv->last_timeend_send_ms);
+
+			if (now_ms - priv->last_timeend_send_ms < 700)
+			{
+//				memcpy(arg, &priv->last_timeend, sizeof(double));
+				*((double *)arg) = priv->last_timeend;
+				return STREAM_OK;
+			}
+
+			pos = -1;
+			while (pos == -1)
+			{
+				protocol_get_tuner_time_endpos(s->fd);
+				p = recv(priv->handle, &pos, sizeof(uint64_t), 0);
+		//		printf("GOT : %d -- %" PRId64" -- 0x%lx\n", p, sizeof(uint64_t), pos);
+			}
+//			printf("C4\n");
+
+//			printf("Req. Done: %" PRId64" (%0.f) -- bytes left: %d\n", pos, pos/90000.0, p);
+
+			if ((int64_t)pos != -1)
+			{
+				priv->last_timeend_send_ms = now_ms;
+				*((double*)arg) = priv->last_timeend = (double)pos/90000.0;
+				return STREAM_OK;
+			}
+		}
+		break;
+
+		case STREAM_CTRL_SEEK_TO_TIME: // 6
+		{
+			int b=0;
+			uint8_t tmp1 = 0;
+			uint32_t loop1_count = 0;
+			int rc = 0;
+			priv->is_seeking = 1;
+			if (*((double*)arg) < 0)
+				pos = LIVE_POS;
+			else
+				pos = floor(*((double*)arg) * 90000);
+
+			printf("---- Seeking to: %0.4f\n", pos/90000.0);
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "---- Seeking to: %0.4f\n", pos/90000.0);
+				fflush(debug_fp);
+			}
+			protocol_set_tuner_time_pos(s->fd, pos);
+			p = recv(priv->handle, &pos, sizeof(uint64_t), 0);
+
+			if ((int64_t)pos == -1)
+			{
+				tmp1 = 0xEE;
+				p = send(priv->handle, &tmp1, 1, 0);
+				printf("SEEK DID NOT HAPPEN\n");
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "SEEK DID NOT HAPPEN\n");
+					fflush(debug_fp);
+				}
+				return STREAM_UNSUPPORTED;
+			}
+//			rc = _flush_incoming_stream(s, -1);
+			rc = _flush_incoming_stream2(s);
+
+			tmp1 = 0xDE;
+			rc = 0;
+			p = send(priv->handle, &tmp1, 1, 0);
+
+			while(b < SEEK_FILL_SZ2)
+			{
+//				b = _flush_incoming_stream(s, 1);
+				b = _wait_incoming_stream(s, 1);
+				if (debug_fp)
+				{
+					fprintf(debug_fp, "Data_wait: %d\n", b);
+				}
+
+				if (b < SEEK_FILL_SZ2)
+				{
+					usleep(100*1000);
+					rc++;
+				}
+
+				if (rc > 20)
+				{
+					printf("Data is NOT flowing: %d\n", rc);
+					if (debug_fp)
+					{
+						fprintf(debug_fp, "Data is NOT flowing: %d\n", rc);
+						fflush(debug_fp);
+					}
+					priv->is_seeking = 0;
+					return 0;
+				}
+			}
+			printf("Data is flowing: %d (%d)\n", rc, b);
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "Data is flowing: %d (%d)\n", rc, b);
+				fflush(debug_fp);
+			}
+			priv->is_seeking = 0;
+			return 1;
+		}
+		break;
+/*
+		case STREAM_CTRL_GET_CURRENT_TIME: // 5
+		case STREAM_CTRL_SEEK_TO_CHAPTER: // 2
+		case STREAM_CTRL_GET_CURRENT_CHAPTER: // 3
+		case STREAM_CTRL_GET_NUM_CHAPTERS: // 4
+		case STREAM_CTRL_GET_ASPECT_RATIO: // 8
+		case STREAM_CTRL_GET_NUM_ANGLES: // 9
+		case STREAM_CTRL_GET_ANGLE: // 10
+		case STREAM_CTRL_SET_ANGLE: // 11
+		case STREAM_CTRL_RESET: //0
+		case STREAM_CTRL_GET_SIZE: // 7
+*/
+		default:
+		break;
+
+	}
+//	printf("control: %d\n", cmd);
+	return STREAM_UNSUPPORTED;
+}
+
+
+static void close_f(stream_t *s)
+{
+	struct stream_priv_s *priv = s->priv;
+//	if (debug_fp)
+//		fclose(debug_fp);
+	if (s->fd > 0)
+		closesocket(s->fd);
+	if (priv->handle)
+		closesocket(priv->handle);
+}
+
+static int open_s(stream_t *stream,int mode, void* opts, int* file_format)
+{
+	struct stream_priv_s* p = opts;
+	if (p->host && p->port && p->filename)
+	{
+//		printf("Host: %s, Port: %d\n", p->host, p->port);
+//		printf("channel: %s\n", p->filename);
+		etp_connect(p);
+
+		if (p->handle > 0)
+		{
+			int q;
+			uint16_t lport = 0;
+			stream->fd = p->handle;
+			p->handle = 0;
+			stream->sector_size = 188;
+			stream->read_chunk = 188*200;
+			stream->priv = p;
+			stream->type = STREAMTYPE_ETP;
+			protocol_set_tuner_channel(stream->fd, atoi(p->filename));
+			q = recv(stream->fd, &lport, sizeof(uint16_t), 0);
+
+			if (!debug_fp)
+			{
+//				debug_fp = fopen("/tmp/etp_control.txt", "a+");
+			}
+			printf("Recvied port: %d (%d)\n", lport, q);
+
+			if (debug_fp)
+			{
+				fprintf(debug_fp, "Channel: %s\n", p->filename);
+				fprintf(debug_fp, "Recvied port: %d (%d)\n", lport, q);
+				fflush(debug_fp);
+			}
+
+			if (q && lport)
+			{
+				p->handle = connect2Server(p->host, lport, 0);
+				if (p->handle)
+				{
+					printf("Connection made!\n");
+
+					if (debug_fp)
+					{
+						fprintf(debug_fp, "Connection made!\n");
+						fflush(debug_fp);
+					}
+					stream->control = control;
+ //					stream->streaming_ctrl->prebuffer_size = 64*1024; // 64 KBytes
+//					stream->streaming_ctrl->buffering = 1;
+				}
+				else
+				{
+					printf("No Connection made :(\n");
+					if (debug_fp)
+					{
+						fprintf(debug_fp, "No Connection made :(\n");
+						fflush(debug_fp);
+					}
+				}
+			}
+
+			stream->close = close_f;
+			stream->fill_buffer = fill_buffer;
+		}
+	}
+	else
+	{
+		mp_msg(MSGT_OPEN,MSGL_ERR, "[etp] info missing\n");
+		return STREAM_ERROR;
+	}
+	return STREAM_OK;
+}
+
+const stream_info_t stream_info_etp =
+{
+	"Ed Transfer Protocol",
+	"etp",
+	"edng",
+	"insert comment here",
+	open_s,
+	{ "etp", NULL },
+	&stream_opts,
+	1
+};
--- stream/stream.c.org	2013-03-18 00:59:52.045842690 -0400
+++ stream/stream.c	2013-03-17 23:53:25.090929836 -0400
@@ -88,6 +88,7 @@
 extern const stream_info_t stream_info_ifo;
 extern const stream_info_t stream_info_dvd;
 extern const stream_info_t stream_info_bluray;
+extern const stream_info_t stream_info_etp;
 
 static const stream_info_t* const auto_open_streams[] = {
 #ifdef CONFIG_VCD
@@ -103,6 +105,7 @@
   &stream_info_rtp,
   &stream_info_udp,
   &stream_info_http2,
+  &stream_info_etp,
 #endif
 #ifdef CONFIG_DVBIN
   &stream_info_dvb,
--- stream/stream.h.org	2013-03-18 00:59:45.852842825 -0400
+++ stream/stream.h	2013-03-17 23:54:16.798928706 -0400
@@ -54,6 +54,7 @@
 #define STREAMTYPE_MF 18
 #define STREAMTYPE_RADIO 19
 #define STREAMTYPE_BLURAY 20
+#define STREAMTYPE_ETP 21
 
 #define STREAM_BUFFER_SIZE 2048
 #define STREAM_MAX_SECTOR_SIZE (8*1024)
@@ -94,6 +95,7 @@
 #define STREAM_CTRL_GET_NUM_ANGLES 9
 #define STREAM_CTRL_GET_ANGLE 10
 #define STREAM_CTRL_SET_ANGLE 11
+#define STREAM_CTRL_GET_TIME_START 12
 
 
 typedef enum {
--- mplayer.c.org	2013-03-18 01:03:47.993837533 -0400
+++ mplayer.c	2013-03-18 01:08:37.428831206 -0400
@@ -110,6 +110,8 @@
 
 #include "input/input.h"
 
+#define ETP_MAX_FROM_END		3.4
+int etp_video_sync = 0;
 int slave_mode = 0;
 int enable_mouse_movements = 0;
 float start_volume = -1;
@@ -2833,6 +2835,25 @@
         // timer now
         if (vf_output_queued_frame(sh_video->vfilter))
             break;
+        while (etp_video_sync == 0 && mpctx->stream->type == STREAMTYPE_ETP && mpctx->stream->control)
+        {
+            double tmp = 0;
+            if ((*mpctx->stream->control)(mpctx->stream, STREAM_CTRL_GET_TIME_LENGTH, &tmp) != STREAM_UNSUPPORTED)
+            {
+//                printf("ETP TYPE: %0.4f -- %0.4f\n", mpctx->demuxer->stream_pts, tmp);
+                if (tmp - mpctx->demuxer->stream_pts < ETP_MAX_FROM_END)
+                {
+                    set_osd_msg(OSD_MSG_TEXT, 1, 2, "Buffering.. ");
+                    usec_sleep(1000*1000);
+                    continue;
+                }
+                else
+                {
+//                    printf("ETP Synced\n");
+                    etp_video_sync = 1;
+                }
+            }
+        }
         int in_size = 0;
         unsigned char *buf = NULL;
         pts = MP_NOPTS_VALUE;
@@ -3180,13 +3201,25 @@
     int seekresult = demux_seek(mpctx->demuxer, demuxer_amount, audio_delay,
                                 demuxer_style);
     if (seekresult == 0) {
+        if (mpctx->stream->type == STREAMTYPE_ETP)
+        {
+            if (demuxer_amount > 0)
+            {
+                set_osd_msg(OSD_MSG_TEXT, 1, opts->osd_duration, "LIVE");
+            }
+            else if (demuxer_amount < 0)
+            {
+                set_osd_msg(OSD_MSG_TEXT, 1, opts->osd_duration, "START");
+            }
+            need_reset = 0;
+        }
         if (need_reset) {
             reinit_audio_chain(mpctx);
             seek_reset(mpctx, !timeline_fallthrough, false);
         }
         return -1;
     }
-
+    etp_video_sync = 0;
     if (need_reset)
         reinit_audio_chain(mpctx);
     /* If we just reinitialized audio it doesn't need to be reset,
--- libmpdemux/demuxer.c.org	2013-03-18 01:11:07.588827924 -0400
+++ libmpdemux/demuxer.c	2013-03-18 00:50:45.681854632 -0400
@@ -1172,29 +1173,32 @@
         return 0;
     }
     // clear demux buffers:
-    demux_flush(demuxer);
-    demuxer->video->eof = 0;
-    demuxer->audio->eof = 0;
-    demuxer->sub->eof = 0;
+    if (demuxer->stream->type != STREAMTYPE_ETP)
+    {
+        demux_flush(demuxer);
+        demuxer->video->eof = 0;
+        demuxer->audio->eof = 0;
+        demuxer->sub->eof = 0;
+    }
 
     /* HACK: assume any demuxer used with these streams can cope with
      * the stream layer suddenly seeking to a different position under it
      * (nothing actually implements DEMUXER_CTRL_RESYNC now).
      */
     struct stream *stream = demuxer->stream;
-    if (stream->type == STREAMTYPE_DVD || stream->type == STREAMTYPE_DVDNAV) {
-        double pts;
+    if (stream->type == STREAMTYPE_DVD || stream->type == STREAMTYPE_DVDNAV || stream->type == STREAMTYPE_ETP) {
+        double pts, tmp = 0;
 
         if (flags & SEEK_ABSOLUTE)
             pts = 0.0f;
         else {
             if (demuxer->stream_pts == MP_NOPTS_VALUE)
                 goto dmx_seek;
+
             pts = demuxer->stream_pts;
         }
 
         if (flags & SEEK_FACTOR) {
-            double tmp = 0;
             if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH,
                                &tmp) == STREAM_UNSUPPORTED)
                 goto dmx_seek;
@@ -1202,11 +1206,58 @@
         } else
             pts += rel_seek_secs;
 
+
+        if (stream->type == STREAMTYPE_ETP)
+        {
+            if (rel_seek_secs > 0)
+            {
+                if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH,
+    	                           &tmp) != STREAM_UNSUPPORTED)
+                {
+                    double diff = (tmp - demuxer->stream_pts);
+//                    printf("PTS+: %0.4f, Seek to: %0.4f, End: %0.4f -- Diff: %0.4f\n", demuxer->stream_pts, pts, tmp, diff);
+
+                    if (diff < 5)
+                        return 0;
+
+                    if (!(diff - 4 > rel_seek_secs))
+                        pts = tmp - 4;
+                    if (tmp - pts <= 2)
+                        pts = -1; 
+                }
+            }
+            else
+            {
+                if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_START,
+    	                           &tmp) != STREAM_UNSUPPORTED)
+                {
+                    double diff = (demuxer->stream_pts - tmp);
+//                    printf("PTS-: %0.4f, Seek to: %0.4f, End: %0.4f -- Diff: %0.4f\n", demuxer->stream_pts, pts, tmp, diff);
+					if (diff < 3)
+						return 0;
+                }
+                pts--;
+                if (pts < 0)
+                    pts = .5;
+            }
+        }
+
+//      printf("Seek to: %0.4f\n", pts);
         if (stream_control(demuxer->stream, STREAM_CTRL_SEEK_TO_TIME, &pts)
             != STREAM_UNSUPPORTED) {
+            printf("Demux Seeked\n");
+            demux_flush(demuxer);
+            demuxer->video->eof = 0;
+            demuxer->audio->eof = 0;
+            demuxer->sub->eof = 0;
             demux_control(demuxer, DEMUXER_CTRL_RESYNC, NULL);
             return 1;
         }
+        else
+        {
+            printf("Demux NO Seek\n");
+            return 0;
+        }
     }
 
   dmx_seek:
--- libmpdemux/demux_ts.c.org	2013-03-18 01:13:21.468824998 -0400
+++ libmpdemux/demux_ts.c	2013-03-18 00:52:30.866852333 -0400
@@ -3124,6 +3156,7 @@
 				mp_msg(MSGT_DEMUX, MSGL_DBG2, "ts_parse, NEW pid=%d, PSIZE: %u, type=%X, start=%p, len=%d\n",
 					es->pid, es->payload_size, es->type, es->start, es->size);
 
+				demuxer->stream_pts = es->pts;
 				demuxer->filepos = stream_tell(demuxer->stream) - es->size;
 
 				if(es->size < 0 || es->size > buf_size) {
@@ -3240,6 +3273,68 @@
 	demuxer->reference_clock = MP_NOPTS_VALUE;
 }
 
+static void demux_seek_resync_ts(demuxer_t *demuxer)
+{
+	demux_stream_t *d_audio=demuxer->audio;
+	demux_stream_t *d_video=demuxer->video;
+	sh_audio_t *sh_audio=d_audio->sh;
+	sh_video_t *sh_video=d_video->sh;
+	ts_priv_t * priv = (ts_priv_t*) demuxer->priv;
+	int i, video_stats;
+
+	ts_dump_streams(demuxer->priv);
+	reset_fifos(demuxer, 1, 1, 0);
+
+	demux_flush(demuxer);
+
+	ds_free_packs(demuxer->video);
+	ds_free_packs(demuxer->audio);
+
+	for(i = 0; i < NB_PID_MAX; i++)
+		if(priv->ts.pids[i] != NULL)
+			priv->ts.pids[i]->is_synced = 0;
+
+	videobuf_code_len = 0;
+
+	if(sh_video != NULL)
+		ds_fill_buffer(d_video);
+
+	if(sh_audio != NULL)
+	{
+		ds_fill_buffer(d_audio);
+	}
+
+	while(sh_video != NULL)
+	{
+		if(sh_audio && !d_audio->eof && d_video->pts && d_audio->pts)
+		{
+			double a_pts=d_audio->pts;
+			a_pts+=(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(double)sh_audio->i_bps;
+			if(d_video->pts > a_pts)
+			{
+				skip_audio_frame(sh_audio);  // sync audio
+				continue;
+			}
+		}
+
+
+		i = sync_video_packet(d_video);
+		if((sh_video->format == VIDEO_MPEG1) || (sh_video->format == VIDEO_MPEG2))
+		{
+			if(i==0x1B3 || i==0x1B8) break; // found it!
+		}
+		else if((sh_video->format == VIDEO_MPEG4) && (i==0x1B6))
+			break;
+		else if(sh_video->format == VIDEO_VC1 && (i==0x10E || i==0x10F))
+			break;
+		else	//H264
+		{
+			if((i & ~0x60) == 0x105 || (i & ~0x60) == 0x107) break;
+		}
+
+		if(!i || !skip_video_packet(d_video)) break; // EOF?
+	}
+}
 
 static void demux_seek_ts(demuxer_t *demuxer, float rel_seek_secs, float audio_delay, int flags)
 {
@@ -3510,6 +3621,36 @@
 			return DEMUXER_CTRL_OK;
 		}
 
+		case DEMUXER_CTRL_GET_TIME_LENGTH:
+			if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH, arg) != STREAM_UNSUPPORTED)
+				return DEMUXER_CTRL_OK;
+		break;
+/*
+		case DEMUXER_CTRL_GET_TIME_START:
+			if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_START, arg) != STREAM_UNSUPPORTED)
+				return DEMUXER_CTRL_OK;
+		break;
+*/
+		case DEMUXER_CTRL_RESYNC:
+			demux_seek_resync_ts(demuxer);
+			return DEMUXER_CTRL_OK;
+		break;
+
+		case DEMUXER_CTRL_GET_PERCENT_POS:
+		{
+			double tmp;
+			if (stream_control(demuxer->stream, STREAM_CTRL_GET_TIME_LENGTH, &tmp) != STREAM_UNSUPPORTED)
+			{
+				if (tmp - demuxer->stream_pts < 5)
+					*((int *)arg) = 100;
+				else
+					*((int *)arg) = (int) ceil(((demuxer->stream_pts/tmp) * 100));
+				return DEMUXER_CTRL_OK;
+			}
+			return DEMUXER_CTRL_NOTIMPL;
+		}
+		break;
+
 		default:
 			return DEMUXER_CTRL_NOTIMPL;
 	}
